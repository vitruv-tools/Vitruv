import edu.kit.ipd.sdq.metamodels.families.Family
import edu.kit.ipd.sdq.metamodels.persons.Male

import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers
import static extension tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.getFirstname
import static extension tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.getLastname
import static extension tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.getRegister
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.askUserWhichFamilyToInsertTheMemberIn
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.doesUserPreferChildOverParent
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.doesUserPreferChildOverParentDuringRenaming
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.sameLastname
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.noParent
import edu.kit.ipd.sdq.metamodels.persons.Female

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: personsToFamilies
in reaction to changes in Persons
execute actions in Families

// =================================
// Creation/ deletion of a registers
// =================================

reaction CreatedPersonRegister {
	after element persons::PersonRegister created and inserted as root
	call createFamilyRegister(newValue)
}

routine createFamilyRegister(persons::PersonRegister createdPersonRegister) {
	action {
		val newFamilyRegister = create families::FamilyRegister and initialize {
			persistProjectRelative(createdPersonRegister, newFamilyRegister, "model/families.families")
		}
		add correspondence between newFamilyRegister and createdPersonRegister
	}
}


reaction DeletedPersonRegister {
	after element persons::PersonRegister deleted
	call deleteFamilyRegister(affectedEObject)
}

routine deleteFamilyRegister(persons::PersonRegister deletedPersonsRegister) {
	match {
		val familyRegister = retrieve families::FamilyRegister corresponding to deletedPersonsRegister
	}
	action {
		delete familyRegister
	}
}

// ========================
// New creation of a member
// ========================

reaction CreatedPerson {
	after element persons::Person created and inserted in persons::PersonRegister[persons]
	call insertAsParentOrChild(newValue)
}

routine insertAsParentOrChild(persons::Person insertedPerson) {
	action {
		call {
			val boolean userWantsPersontoBeAChild = doesUserPreferChildOverParent(userInteractor, insertedPerson)
			if (userWantsPersontoBeAChild) {
				createChild(insertedPerson)
			} else {
				createParent(insertedPerson)
			}
		}
	}
}

routine createChild(persons::Person insertedPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to insertedPerson.register
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = familiesRegister.families.filter(sameLastname(insertedPerson))	
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, insertedPerson, matchingFamilies)
			if (chosenFamily === null) {
				createChildInNewFamily(insertedPerson)
			} else {
				createChildInExistingFamily(insertedPerson, chosenFamily)
			}
		}
	}
}

routine createParent(persons::Person insertedPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to insertedPerson.register
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = familiesRegister.families.filter(sameLastname(insertedPerson)).filter(noParent(insertedPerson))
			var Family familyToInsertInto = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, insertedPerson, matchingFamilies)
			if (familyToInsertInto === null) {
				createParentInNewFamily(insertedPerson)
			} else {
				createParentInExistingFamily(insertedPerson, familyToInsertInto)
			}
		}
	}
}

routine createChildInNewFamily(persons::Person insertedPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to insertedPerson.register
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = insertedPerson.lastname
		}
		update familiesRegister {
			familiesRegister.families += newFamily
		}
		call createChildInExistingFamily(insertedPerson, newFamily)
	}
}

routine createParentInNewFamily(persons::Person insertedPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to insertedPerson.register
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = insertedPerson.lastname
		}
		update familiesRegister {
			familiesRegister.families += newFamily
		}
		call createParentInExistingFamily(insertedPerson, newFamily)
	}
}

routine createChildInExistingFamily(persons::Person insertedPerson, families::Family familyToInsertInto) {
	action {
		val newMember = create families::Member and initialize { 
			newMember.firstName = insertedPerson.firstname
		}
		update familyToInsertInto {
			switch insertedPerson {
				Male: familyToInsertInto.sons += newMember
				Female: familyToInsertInto.daughters += newMember
			}
		}
		add correspondence between insertedPerson and familyToInsertInto
		add correspondence between insertedPerson and newMember
	}
}

routine createParentInExistingFamily(persons::Person insertedPerson, families::Family familyToInsertInto) {
	action {
		val newMember = create families::Member and initialize { 
			newMember.firstName = insertedPerson.firstname
		}
		update familyToInsertInto {
			switch insertedPerson {
				Male: familyToInsertInto.father = newMember
				Female: familyToInsertInto.mother = newMember
			}
		}
		add correspondence between insertedPerson and familyToInsertInto
		add correspondence between insertedPerson and newMember
	}
}

// ==============================================================
// Inserting existing member into different family after renaming 
// ==============================================================

reaction ChangedFullName {
	after attribute replaced at persons::Person[fullName]
		with oldValue !== null
	call changeNames(affectedEObject, oldValue)
}
/* Apply firstname changes to the corresponding {@link Member}
 * Apply lastname changes to the corresponding {@link Family}
 */ 
routine changeNames(persons::Person renamedPerson, String oldFullname) {
	match {
		val oldFamily = retrieve families::Family corresponding to renamedPerson
		val correspondingMember = retrieve families::Member corresponding to renamedPerson		
	}
	action {
		// Check valid name
		call {			
			if (renamedPerson.fullName === null) {
				throw new IllegalArgumentException("New name is not allowed to be null.")
			}	
			if (renamedPerson.fullName.equals("")) {
				throw new IllegalArgumentException("New name is not allowed to be empty.")
			}			
		}
		// Update firstname 
		update correspondingMember {
			correspondingMember.firstName = renamedPerson.firstname
		}
		// Update lastname and/or position
		call reactToLastnameAndPositionChanges(renamedPerson, oldFullname)
	}
}

routine reactToLastnameAndPositionChanges(persons::Person renamedPerson, String oldFullname) {
	match {
		val oldFamily = retrieve families::Family corresponding to renamedPerson
		val correspondingMember = retrieve families::Member corresponding to renamedPerson		
	}
	action {	
		call {		
			val renamedPersonIsMale = renamedPerson instanceof Male			
			val boolean wasChildBeforeRenaming = if (renamedPersonIsMale) correspondingMember.familySon === oldFamily else correspondingMember.familyDaughter === oldFamily			
			val boolean isSupposedToBeAChild = doesUserPreferChildOverParentDuringRenaming(userInteractor, oldFullname, renamedPerson.fullName, wasChildBeforeRenaming)
			
			// If neither the lastname, nor the position of the member inside the family changed,
			// then only the firstname changed and nothing else must be done. 
			if((wasChildBeforeRenaming !== isSupposedToBeAChild) || (oldFamily.lastName != renamedPerson.lastname)){
				if (oldFamily.members.size == 1) {
					// If the member is alone in its family just rename the oldFamily 
					// and maybe adjust the position of the member which is no problem
					// since the member is alone.
					oldFamily.lastName = renamedPerson.lastname
					// and re-insert member as either child or parent if position is supposed to change 				 
					if (wasChildBeforeRenaming !== isSupposedToBeAChild) {
						if (isSupposedToBeAChild) {
							if (renamedPersonIsMale) {
								oldFamily.father = correspondingMember							
							} else {
								oldFamily.mother = correspondingMember
							}
						} else {
							if (renamedPersonIsMale) {
								oldFamily.sons += correspondingMember							
							} else {
								oldFamily.daughters += correspondingMember
							}
						}
					} 
				} else {
					// If the member is not alone move it to 
					// a different family depending on lastname and supposed position
					if (isSupposedToBeAChild) {
						insertExistingMemberIntoUserChosenFamilyAsChild(renamedPerson, correspondingMember)
					} else {
						insertExistingMemberIntoUserChosenFamilyAsParent(renamedPerson, correspondingMember)
					}
				}	
			}	
		}
	}	
}

routine insertExistingMemberIntoUserChosenFamilyAsParent(persons::Person renamedPerson, families::Member correspondingMember) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to renamedPerson.register
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = familiesRegister.families.filter(sameLastname(renamedPerson)).filter(noParent(renamedPerson))
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, renamedPerson, matchingFamilies)
			if (chosenFamily === null) {
				insertExistingMemberIntoNewFamilyAsParent(renamedPerson, correspondingMember)
			} else {
				insertExistingMemberIntoExistingFamilyAsParent(renamedPerson, correspondingMember, chosenFamily)
			}
		}
	}
}

routine insertExistingMemberIntoUserChosenFamilyAsChild(persons::Person renamedPerson, families::Member correspondingMember) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to renamedPerson.register
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = familiesRegister.families.filter(sameLastname(renamedPerson))
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, renamedPerson, matchingFamilies)
			if (chosenFamily === null) {
				insertExistingMemberIntoNewFamilyAsChild(renamedPerson, correspondingMember)
			} else {
				insertExistingMemberIntoExistingFamilyAsChild(renamedPerson, correspondingMember, chosenFamily)
			}
		}
	}
}

routine insertExistingMemberIntoNewFamilyAsParent(persons::Person renamedPerson, families::Member correspondingMember) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to renamedPerson.register
	}
	action {
		val familyToInsertInto = create families::Family and initialize {
			familyToInsertInto.lastName = renamedPerson.lastname
		}
		update familiesRegister {
			familiesRegister.families += familyToInsertInto
		}
		call insertExistingMemberIntoExistingFamilyAsParent(renamedPerson, correspondingMember, familyToInsertInto)
	}
}

routine insertExistingMemberIntoNewFamilyAsChild(persons::Person renamedPerson, families::Member correspondingMember) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to renamedPerson.register
	}
	action {
		val familyToInsertInto = create families::Family and initialize {
			familyToInsertInto.lastName = renamedPerson.lastname
		}
		update familiesRegister {
			familiesRegister.families += familyToInsertInto
		}
		call insertExistingMemberIntoExistingFamilyAsChild(renamedPerson, correspondingMember, familyToInsertInto)
	}
}

routine insertExistingMemberIntoExistingFamilyAsParent(persons::Person renamedPerson, families::Member correspondingMember, families::Family familyToInsertInto) {
	match {
		val oldFamily = retrieve families::Family corresponding to renamedPerson
	}
	action {
		update familyToInsertInto {
			switch renamedPerson {
				Male: familyToInsertInto.father = correspondingMember
				Female: familyToInsertInto.mother = correspondingMember
			}
		}
		remove correspondence between renamedPerson and oldFamily
		add correspondence between renamedPerson and familyToInsertInto
		//correspondence between newPerson and member does already exist
	}
}

routine insertExistingMemberIntoExistingFamilyAsChild(persons::Person renamedPerson, families::Member correspondingMember, families::Family familyToInsertInto) {	
	match {
		val oldFamily = retrieve families::Family corresponding to renamedPerson
	}
	action {
		update familyToInsertInto {
			switch renamedPerson {
				Male: familyToInsertInto.sons += correspondingMember
				Female: familyToInsertInto.daughters += correspondingMember
			}
		}
		remove correspondence between renamedPerson and oldFamily
		add correspondence between renamedPerson and familyToInsertInto
		//correspondence between newPerson and member does already exist
	}
}

//=================================================================================
// Deletion of a person and therefore of corresponding member and maybe also family
//=================================================================================

reaction DeletePerson {
	after element persons::Person deleted
	call deleteMember(affectedEObject)
}

routine deleteMember(persons::Person person) {
	match {
		val member = retrieve families::Member corresponding to person
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between person and family
		remove correspondence between person and member
		delete member
		call deleteFamilyIfEmpty(family)
	}
}

routine deleteFamilyIfEmpty(families::Family family) {
	match {
		check family.father === null
		check family.mother === null
		check family.sons.empty
		check family.daughters.empty
	}
	action {
		delete family
	}
}