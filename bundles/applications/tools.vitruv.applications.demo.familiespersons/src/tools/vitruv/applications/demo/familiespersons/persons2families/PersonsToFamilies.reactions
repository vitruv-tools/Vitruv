import edu.kit.ipd.sdq.metamodels.families.Family
import edu.kit.ipd.sdq.metamodels.persons.Male

import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.getMatchingFamilies
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.getFamiliesWithoutParent
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.askUserWhichFamilyToInsertTheMemberIn
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.doesUserPreferChildOverParent

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: personsToFamilies
in reaction to changes in Persons
execute actions in Families


reaction CreatedPersonRegister {
	after element persons::PersonRegister created and inserted as root
	call createFamilyRegister(newValue)
}

routine createFamilyRegister(persons::PersonRegister personRegister) {
	action {
		val familyRegister = create families::FamilyRegister and initialize {
			persistProjectRelative(personRegister, familyRegister, "model/families.families")
		}
		add correspondence between familyRegister and personRegister
	}
}


reaction DeletedPersonRegister {
	after element persons::PersonRegister deleted
	call deleteFamilyRegister(affectedEObject)
}

routine deleteFamilyRegister(persons::PersonRegister personsRegister) {
	match {
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {
		delete familyRegister
	}
}


reaction CreatedPerson {
	after element persons::Person created and inserted in persons::PersonRegister[persons]
	call insertAsParentOrChild(newValue)
}

routine insertAsParentOrChild(persons::Person newPerson) {
	action {
		call {
			val boolean decidedChild = doesUserPreferChildOverParent(userInteractor, newPerson)
			if (decidedChild) {
				createChild(newPerson)
			} else {
				createParent(newPerson)
			}
		}
	}
}

routine createChild(persons::Person newPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = getMatchingFamilies(familiesRegister, newPerson)			
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, newPerson, matchingFamilies)
			if (chosenFamily === null) {
				createChildInNewFamily(newPerson)
			} else {
				createChildInExistingFamily(newPerson, chosenFamily)
			}
		}
	}
}

routine createParent(persons::Person newPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = getFamiliesWithoutParent(getMatchingFamilies(familiesRegister, newPerson), newPerson)
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, newPerson, matchingFamilies)
			if (chosenFamily === null) {
				createParentInNewFamily(newPerson)
			} else {
				createParentInExistingFamily(newPerson, chosenFamily)
			}
		}
	}
}

routine moveExistingMemberToDifferentFamily(persons::Person newPerson, Boolean isChild, families::Member member) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			var Iterable<Family> matchingFamilies = getMatchingFamilies(familiesRegister, newPerson)
			if (!isChild) {
				matchingFamilies = getFamiliesWithoutParent(matchingFamilies, newPerson)
			}
			var Family chosenFamily = if (matchingFamilies.empty) null else askUserWhichFamilyToInsertTheMemberIn(userInteractor, newPerson, matchingFamilies)
			if (chosenFamily === null) {
				moveMemberToNewFamily(newPerson, member, isChild)
			} else {
				moveMemberToExistingFamily(newPerson, member, isChild, chosenFamily)
			}
		}
	}
}

routine createChildInNewFamily(persons::Person newPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		update familiesRegister {
			familiesRegister.families += newFamily
		}
		call createChildInExistingFamily(newPerson, newFamily)
	}
}

routine createChildInExistingFamily(persons::Person newPerson, families::Family family) {
	action {
		val newMember = create families::Member and initialize { }
		call setMemberFirstName(newMember, newPerson.fullName)
		call {
			if (newPerson instanceof Male) {
				family.sons += newMember
			} else {
				family.daughters += newMember
			}
		}
		add correspondence between newPerson and family
		add correspondence between newPerson and newMember
	}
}

routine createParentInNewFamily(persons::Person newPerson) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		update familiesRegister {
			familiesRegister.families += newFamily
		}
		call createParentInExistingFamily(newPerson, newFamily)
	}
}

routine createParentInExistingFamily(persons::Person newPerson, families::Family family) {
	action {
		val newMember = create families::Member and initialize { }
		call setMemberFirstName(newMember, newPerson.fullName)
		call {
			if (newPerson instanceof Male) {
				family.father = newMember
			} else {
				family.mother = newMember
			}
		}
		add correspondence between newPerson and family
		add correspondence between newPerson and newMember
	}
}

routine moveMemberToNewFamily(persons::Person newPerson, families::Member member, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		update familiesRegister {
			familiesRegister.families += newFamily
		}
		call moveMemberToExistingFamily(newPerson, member, isChild, newFamily)
	}
}

routine moveMemberToExistingFamily(persons::Person newPerson, families::Member member, Boolean isChild, families::Family family) {
	action {
		call {
			if (newPerson instanceof Male) {
				if (isChild) {
					family.sons += member
				} else {
					family.father = member
				}
			} else {
				if (isChild) {
					family.daughters += member
				} else {
					family.mother = member
				}
			}
		}
		add correspondence between newPerson and family
		//correspondence between newPerson and member does already exist
	}
}

reaction ChangedFullName {
	after attribute replaced at persons::Person[fullName]
	call changeNames(affectedEObject)
}
/* Apply firstname changes to the corresponding {@link Member}
 * Apply lastname changes to the corresponding {@link Family}
 */ 
routine changeNames(persons::Person person) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person		
	}
	action {
		call {
			if (person.fullName.equals("")) {
				throw new IllegalArgumentException("New name is not allowed to be empty.")
			}
		}
		call setMemberFirstName(member, person.fullName)
		call {
			val String newLastname = person.fullName.split(" ").last
			if (!newLastname.equals(family.lastName)) {
				renameFamilyOrMoveMemberToAMatchingFamily(person, newLastname)
			}
		}
	}
}

routine renameFamilyOrMoveMemberToAMatchingFamily(persons::Person person, String newLastname) {
	match {
		val oldFamily = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {			
			if (oldFamily.members.size == 1) {
				//just rename oldFamily
				oldFamily.lastName = newLastname
			} else {
				//move renamed member to a different family
				moveRenamedMemberFromOldFamilyToOtherFamily(person, newLastname)
			}
		}
	}
}

routine moveRenamedMemberFromOldFamilyToOtherFamily(persons::Person person, String newLastname) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			//Find out which position the corresponding member had
			//Here the idea is to keep the position when the member has to leave the family due to a renaming.
			//A father stays a father and a son stays a son (the same for the female versions), because this
			//logic is covered in the families model. The persons model does not know the difference between parent
			//and child and should not be responsible for a change in meaning which it itself does not even show.
			//In contrast to the renaming itself since both models have names for ther persons/ members.
			var boolean isChild = false
			if (person instanceof Male) {
				isChild = member.familySon === family
			} else {
				isChild = member.familyDaughter === family
			}
			moveExistingMemberToDifferentFamily(person, isChild, member)
		}
		remove correspondence between person and family
	}
}

routine setMemberFirstName(families::Member member, String fullName) {
	action {
		update member {
			val Iterable<String> nameParts = fullName.split(" ")
			var String firstName = null
			if (nameParts.size() == 1) {
				firstName = fullName
			} else {
				firstName = nameParts.take(nameParts.size() - 1).join(" ")
			}
			member.firstName = firstName
		}
	}
}

reaction DeletePerson {
	after element persons::Person deleted
	call deleteMember(affectedEObject)
}

routine deleteMember(persons::Person person) {
	match {
		val member = retrieve families::Member corresponding to person
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between person and family
		remove correspondence between person and member
		delete member
		call deleteFamilyIfEmpty(family)
	}
}

routine deleteFamilyIfEmpty(families::Family family) {
	match {
		check family.father === null
		check family.mother === null
		check family.sons.empty
		check family.daughters.empty
	}
	action {
		delete family
	}
}