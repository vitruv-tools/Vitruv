import edu.kit.ipd.sdq.metamodels.families.Family
import edu.kit.ipd.sdq.metamodels.persons.Male
import edu.kit.ipd.sdq.metamodels.persons.PersonRegister
import java.util.ArrayList
import java.util.Collection
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality
import static tools.vitruv.applications.demo.familiespersons.persons2families.PersonsToFamiliesHelper.stringifyFamily

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: personsToFamilies
in reaction to changes in Persons
execute actions in Families


reaction CreatedPersonRegister {
	after element persons::PersonRegister created and inserted as root
	call createFamilyRegister(newValue)
}

routine createFamilyRegister(persons::PersonRegister personRegister) {
	action {
		val familyRegister = create families::FamilyRegister and initialize {
			persistProjectRelative(personRegister, familyRegister, "model/families.families")
		}
		add correspondence between familyRegister and personRegister
	}
}


reaction DeletedPersonRegister {
	after element persons::PersonRegister deleted
	call deleteFamilyRegister(affectedEObject)
}

routine deleteFamilyRegister(persons::PersonRegister personsRegister) {
	match {
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {
		delete familyRegister
	}
}


reaction CreatedPerson {
	after element persons::Person created and inserted in persons::PersonRegister[persons]
	call insertAsParentOrChild(newValue)
}

routine insertAsParentOrChild(persons::Person newPerson) {
	action {
		call {
			var String parentOrChildMessage = "You are about to insert a new member into the family register."
			parentOrChildMessage += " Is this member a parent of a family or a child?"
			var Iterable<String> parentOrChildOptions = #["Parent", "Child"]
			val int parentOrChildSelection = userInteractor
				.singleSelectionDialogBuilder
				.message(parentOrChildMessage)
				.choices(parentOrChildOptions)
				.windowModality(WindowModality.MODAL)
				.startInteraction()
			createOrReinsertMember(newPerson, parentOrChildSelection == parentOrChildOptions.toList.indexOf("Child"), null)
		}
	}
}

routine createOrReinsertMember(persons::Person newPerson, Boolean isChild, families::Member member) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			val String newPersonLastname = newPerson.fullName.split(" ").last
			var boolean askUserForFamily = false
			var Iterable<Family> matchingFamilies = familiesRegister.families.filter[it.lastName.equals(newPersonLastname)]

			if (isChild) {
				askUserForFamily = !matchingFamilies.empty
			} else {
				if (newPerson instanceof Male) {
					matchingFamilies = matchingFamilies.filter[it.father === null]					
				} else {
					matchingFamilies = matchingFamilies.filter[it.mother === null]
				}
				askUserForFamily = matchingFamilies.size > 0
			}

			var Family chosenFamily = null
			if (askUserForFamily) {
				var int whichFamilyIndex = 0
				// Let user select the family
				var String whichFamilyMessage = "Please choose whether you want to create a new family or insert " 
					+ newPerson.fullName + " into one of the existing families."
				//Give only matching families as option.
				val Collection<String> whichFamilyOptions = new ArrayList<String>()
				whichFamilyOptions.^add("insert in a new family")
				matchingFamilies.forEach[whichFamilyOptions.^add(stringifyFamily(it))]				
				whichFamilyIndex = userInteractor
					.singleSelectionDialogBuilder
					.message(whichFamilyMessage)
					.choices(whichFamilyOptions)
					.windowModality(WindowModality.MODAL)
					.startInteraction()
				if (whichFamilyIndex !== 0) {
					chosenFamily = matchingFamilies.get(whichFamilyIndex-1)
				}
			}

			if (chosenFamily === null) {
				if (member !== null) {
					moveExistingMemberToNewFamily(newPerson, isChild, member)
				} else {
					insertInNewFamily(newPerson, isChild)					
				}
			} else {
				if (member !== null) {
					moveExistingMemberToExistingFamily(newPerson, chosenFamily, isChild, member)
				} else {
					insertInExistingFamily(newPerson, chosenFamily, isChild)					
				}
			}
		}
	}
}

routine moveExistingMemberToNewFamily(persons::Person newPerson, Boolean isChild, families::Member member) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		call familiesRegister.families += newFamily
		call moveExistingMemberToExistingFamily(newPerson, newFamily, isChild, member)
	}
}

routine insertInNewFamily(persons::Person newPerson, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		call familiesRegister.families += newFamily
		call insertInExistingFamily(newPerson, newFamily, isChild)
	}
}

routine insertInExistingFamily(persons::Person newPerson, families::Family family, Boolean isChild) {
	action {
		val newMember = create families::Member and initialize {
			
		}
		call setMemberFirstName(newMember, newPerson.fullName)
		add correspondence between newPerson and newMember
		call moveExistingMemberToExistingFamily(newPerson, family, isChild, newMember)
	}
}

routine moveExistingMemberToExistingFamily(persons::Person newPerson, families::Family family, Boolean isChild, families::Member member) {
	action {
		call {
			if (newPerson instanceof Male) {
				if (isChild) {
					family.sons += member
				} else {
					family.father = member
				}
			} else {
				if (isChild) {
					family.daughters += member
				} else {
					family.mother = member
				}
			}
		}
		add correspondence between newPerson and family
	}
}

reaction ChangedFullName {
	after attribute replaced at persons::Person[fullName]
	call changeNames(affectedEObject)
}
/* Apply firstname changes to the corresponding {@link Member}
 * Apply lastname changes to the corresponding {@link Family}
 */ 
routine changeNames(persons::Person person) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call setMemberFirstName(member, person.fullName)
		call {
			val String newLastname = person.fullName.split(" ").last
			if (!newLastname.equals(family.lastName)) {
				applyNewLastnameToMember(person, newLastname)
			}
		}
	}
}

routine applyNewLastnameToMember(persons::Person person, String newLastname) {
	match {
		val oldFamily = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			var int numberOfMembers = oldFamily.sons.size + oldFamily.daughters.size
			if (oldFamily.father !== null) {
				numberOfMembers += 1
			}
			if (oldFamily.mother !== null) {
				numberOfMembers += 1
			}
			
			if (numberOfMembers == 1) {
				//just rename oldFamily
				oldFamily.lastName = newLastname
			} else {
				//move renamed member to a different family
				moveRenamedMemberToADifferentFamily(person, newLastname)
			}
		}
	}
}

routine moveRenamedMemberToADifferentFamily(persons::Person person, String newLastname) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			//Find out which position the corresponding member had
			//Here the idea is to keep the position when the member has to leave the family due to a renaming.
			//A father stays a father and a son stays a son (the same for the female versions), because this
			//logic is covered in the families model. The persons model does not know the difference between parent
			//and child and should not be responsible for a change in meaning which it itself does not even show.
			//In contrast to the renaming itself since both models have names for ther persons/ members.
			var boolean isChild = false
			if (person instanceof Male) {
				isChild = member.familyFather !== family
			} else {
				isChild = member.familyMother !== family
			}
			createOrReinsertMember(person, isChild, member)
		}
		remove correspondence between person and family
	}
}

routine setMemberFirstName(families::Member member, String fullName) {
	action {
		call {
			val Iterable<String> nameParts = fullName.split(" ")
			var String firstName = null
			if (nameParts.size() == 1) {
				firstName = fullName
			} else {
				firstName = nameParts.take(nameParts.size() - 1).join(" ")
			}
			member.firstName = firstName
		}
	}
}

reaction DeletePerson {
	after element persons::Person deleted
	call deleteMember(affectedEObject)
}

routine deleteMember(persons::Person person) {
	match {
		val member = retrieve families::Member corresponding to person
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between person and member
		remove correspondence between person and family
		delete member
		call deleteFamilyIfEmpty(family)
	}
}

routine deleteFamilyIfEmpty(families::Family family) {
	match {
		check family.father === null
		check family.mother === null
		check family.sons.empty
		check family.daughters.empty
	}
	action {
		delete family
	}
}