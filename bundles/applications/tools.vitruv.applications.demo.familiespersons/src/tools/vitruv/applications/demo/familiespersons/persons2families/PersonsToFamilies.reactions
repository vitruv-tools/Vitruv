import edu.kit.ipd.sdq.metamodels.families.Family
import edu.kit.ipd.sdq.metamodels.persons.Male
import edu.kit.ipd.sdq.metamodels.persons.PersonRegister
import java.util.ArrayList
import java.util.Collection
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: personsToFamilies
in reaction to changes in Persons
execute actions in Families


reaction CreatedPersonRegister {
	after element persons::PersonRegister created and inserted as root
	call createFamilyRegister(newValue)
}

routine createFamilyRegister(persons::PersonRegister personRegister) {
	action {
		val familyRegister = create families::FamilyRegister and initialize {
			persistProjectRelative(personRegister, familyRegister, "model/families.families")
		}
		add correspondence between familyRegister and personRegister
	}
}


reaction DeletedPersonRegister {
	after element persons::PersonRegister deleted
	call deleteFamilyRegister(affectedEObject)
}

routine deleteFamilyRegister(persons::PersonRegister personsRegister) {
	match {
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {
		delete familyRegister
	}
}


reaction CreatedPerson {
	after element persons::Person created and inserted in persons::PersonRegister[persons]
	call insertAsParentOrChild(newValue)
}

routine insertAsParentOrChild(persons::Person newPerson) {
	action {
		call {
			var String parentOrChildMessage = "You are about to insert a new member into the family register."
			parentOrChildMessage += " Is this member a parent of a family or a child?"
			var Iterable<String> parentOrChildOptions = #["Parent", "Child"]
			val int parentOrChildSelection = userInteractor
				.singleSelectionDialogBuilder
				.message(parentOrChildMessage)
				.choices(parentOrChildOptions)
				.windowModality(WindowModality.MODAL)
				.startInteraction()
			createMember(newPerson, parentOrChildSelection == 1)
		}
	}
}

routine createMember(persons::Person newPerson, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			val String newPersonLastname = newPerson.fullName.split(" ").last
			var boolean askUserForFamily = false
			val Iterable<Family> matchingFamilies = familiesRegister.families.filter[it.lastName.equals(newPersonLastname)]

			if (isChild) {
				askUserForFamily = !matchingFamilies.empty
			} else {
				if (newPerson instanceof Male) {
					askUserForFamily = matchingFamilies.exists[it.father === null]
				}
				else {
					askUserForFamily = matchingFamilies.exists[it.mother === null]
				}
			}

			var Family chosenFamily = null
			if (askUserForFamily) {
				var int whichFamilyIndex = 0
				// Let user select the family
				var String whichFamilyMessage = "Please choose whether you want to create a new family or insert " 
					+ newPerson.fullName + " into one of the existing families."
				//Give only matching families as option.
				val Collection<String> whichFamilyOptions = new ArrayList<String>()
				whichFamilyOptions.^add("insert in a new family")
				matchingFamilies.forEach[
					var newOption = it.lastName + ": "; 
					if (it.father !== null) { newOption += "F: " + it.father.firstName + ";" }
					if (it.mother !== null) { newOption += "M: " + it.mother.firstName + ";" }
					if (it.sons !== null && it.sons.size > 0) { newOption += it.sons.join("S: (", ", ", ")", [it.firstName]) }
					if (it.daughters !== null && it.daughters.size > 0) { newOption += it.daughters.join("S: (", ", ", ")", [it.firstName]) }
					whichFamilyOptions.^add(newOption)
				]
				whichFamilyIndex = userInteractor
					.singleSelectionDialogBuilder
					.message(whichFamilyMessage)
					.choices(whichFamilyOptions)
					.windowModality(WindowModality.MODAL)
					.startInteraction()
				if (whichFamilyIndex !== 0) {
					chosenFamily = matchingFamilies.get(whichFamilyIndex-1)
				}
			}

			if (chosenFamily === null) {
				insertInNewFamily(newPerson, isChild)
			} else {
				insertInExistingFamily(newPerson, chosenFamily, isChild)
			}
		}
	}
}

routine insertInNewFamily(persons::Person newPerson, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		call familiesRegister.families += newFamily
		call insertInExistingFamily(newPerson, newFamily, isChild)
	}
}

routine insertInExistingFamily(persons::Person newPerson, families::Family family, Boolean isChild) {
	action {
		val newMember = create families::Member and initialize {}
		call setMemberFirstName(newMember, newPerson.fullName)
		call {
			if (newPerson instanceof Male) {
				if (isChild) {
					family.sons += newMember
				} else {
					family.father = newMember
				}
			} else {
				if (isChild) {
					family.daughters += newMember
				} else {
					family.mother = newMember
				}
			}
		}
		add correspondence between newPerson and newMember
		add correspondence between newPerson and family
	}
}

reaction ChangedFullName {
	after attribute replaced at persons::Person[fullName]
	call changeNames(affectedEObject)
}
/* Apply firstname changes to the corresponding {@link Member}
 * Apply lastname changes to the corresponding {@link Family}
 */ 
routine changeNames(persons::Person person) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			val String newLastname = person.fullName.split(" ").last
			if (!newLastname.equals(family.lastName)) {
				editLastnameRemovePerson(person, newLastname)
			}
		}
		call setMemberFirstName(member, person.fullName)
	}
}

routine editLastnameRemovePerson(persons::Person person, String fullName) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			//Find out which position the corresponding member had
			var boolean isChild = false
			if (person instanceof Male) {
				isChild = member.familyFather !== family
			} else {
				isChild = member.familyMother !== family
			}
			deleteMember(person)
			createMember(person, isChild)
		}
	}
}

routine setMemberFirstName(families::Member member, String fullName) {
	action {
		call {
			val Iterable<String> nameParts = fullName.split(" ")
			var String firstName = null
			if (nameParts.size() == 1) {
				firstName = fullName
			} else {
				firstName = nameParts.take(nameParts.size() - 1).join(" ")
			}
			member.firstName = firstName
		}
	}
}

reaction DeletePerson {
	after element persons::Person deleted
	call deleteMember(affectedEObject)
}

routine deleteMember(persons::Person person) {
	match {
		val member = retrieve families::Member corresponding to person
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between person and member
		remove correspondence between person and family
		delete member
		call deleteFamilyIfLastMemberWasDeleted(family)
	}
}

routine deleteFamilyIfLastMemberWasDeleted(families::Family family) {
	match {
		check family.father === null
		check family.mother === null
		check family.sons.empty
		check family.daughters.empty
	}
	action {
		delete family
	}
}