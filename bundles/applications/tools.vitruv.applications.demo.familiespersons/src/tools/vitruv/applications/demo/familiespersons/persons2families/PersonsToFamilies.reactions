import edu.kit.ipd.sdq.metamodels.families.Family
import edu.kit.ipd.sdq.metamodels.persons.Male
import edu.kit.ipd.sdq.metamodels.persons.PersonRegister
import java.util.ArrayList
import java.util.Collection
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: personsToFamilies
in reaction to changes in Persons
execute actions in Families


//========== PERSON-REGISTER ==========
/* Creation of a {@link FamilyRegister} after a {@link PersonRegister} was created.
 */
reaction CreatedPersonRegister {
	after element persons::PersonRegister created and inserted as root
	call createFamilyRegister(newValue)
}

routine createFamilyRegister(persons::PersonRegister personRegister) {
	action {
		val familyRegister = create families::FamilyRegister and initialize {
			persistProjectRelative(personRegister, familyRegister, "model/families.families")
		}
		add correspondence between familyRegister and personRegister
	}
}
/* Deletion of a {@link FamilyRegister} after a {@link PersonRegister} was deleted.
 */

reaction DeletedPersonRegister {
	after element persons::PersonRegister deleted
	call deleteFamilyRegister(affectedEObject)
}

routine deleteFamilyRegister(persons::PersonRegister personsRegister) {
	match {
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {
		delete familyRegister
	}
}


//========== MALE ==========
reaction CreatedMale {
	after element persons::Male created and inserted in persons::PersonRegister[persons]
	call createMale(newValue)
}

routine createMale(persons::Male newMale) {
	action {
		call {
			var String fatherOrSonMessage = "You are about to insert a new male person into the family register."
			fatherOrSonMessage += " Is this person the father of a family or a son?"
			var Iterable<String> fatherOrSonOptions = #["Father", "Son"]
			val int fatherOrSonSelection = userInteractor.singleSelectionDialogBuilder.message(fatherOrSonMessage)
			.choices(fatherOrSonOptions).windowModality(WindowModality.MODAL).startInteraction()

			createPerson(newMale, fatherOrSonSelection == 1)
		}
	}
}


//========== FEMALE ==========
reaction CreatedFemale {
	after element persons::Female created and inserted in persons::PersonRegister[persons]
	call createFemale(newValue)
}

routine createFemale(persons::Female newFemale) {
	action {
		call {
			var String motherOrDaughterMessage = "You are about to insert a new female person into the family register."
			motherOrDaughterMessage += " Is this person the mother of a family or a daughter?"
			var Iterable<String> motherOrDaughterOptions = #["Mother", "Daughter"]
			val int motherOrDaughterSelection = userInteractor.singleSelectionDialogBuilder.message(motherOrDaughterMessage)
			.choices(motherOrDaughterOptions).windowModality(WindowModality.MODAL).startInteraction()

			createPerson(newFemale, motherOrDaughterSelection == 1)
		}
	}
}


//========== PERSON IN GENERAL ==========
routine createPerson(persons::Person newPerson, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		call {
			val String newFemaleLastname = newPerson.fullName.split(" ").last
			var boolean askUserForFamily = false
			val Iterable<Family> matchingFamilies = familiesRegister.families.filter[it.lastName.equals(newFemaleLastname)]

			if (isChild) {
				askUserForFamily = !matchingFamilies.empty
			} else {
				if (newPerson instanceof Male) {
					askUserForFamily = matchingFamilies.exists[it.father === null]
				}
				else {
					askUserForFamily = matchingFamilies.exists[it.mother === null]
				}
			}

			var Family chosenFamily = null
			if (askUserForFamily) {
				var int whichFamilyIndex = 0
				// Let user select the family
				var String whichFamilyMessage = "Please choose whether you want to create a new family or insert " 
					+ newPerson.fullName + " into one of the existing families."
				//Give only matching families as option.
				val Collection<String> whichFamilyOptions = new ArrayList<String>()
				whichFamilyOptions.^add("insert in a new family")
				matchingFamilies.forEach[
					var newOption = it.lastName + ": "; 
					if (it.father !== null) { newOption += "F: " + it.father.firstName + ";" }
					if (it.mother !== null) { newOption += "M: " + it.mother.firstName + ";" }
					if (it.sons !== null && it.sons.size > 0) { newOption += it.sons.join("S: (",", ",")",[it.firstName]) }
					if (it.daughters !== null && it.daughters.size > 0) { newOption += it.daughters.join("S: (",", ",")",[it.firstName]) }
					whichFamilyOptions.^add(newOption)
				]
				whichFamilyIndex = userInteractor.singleSelectionDialogBuilder.message(whichFamilyMessage)
				.choices(whichFamilyOptions).windowModality(WindowModality.MODAL).startInteraction()
				if (whichFamilyIndex !== 0) {
					chosenFamily = matchingFamilies.get(whichFamilyIndex-1)
				}
			}

			if (chosenFamily === null) {
				insertInNewFamily(newPerson, isChild)
			} else {
				insertInExistingFamily(newPerson, chosenFamily, isChild)
			}
		}
	}
}

routine insertInNewFamily(persons::Person newPerson, Boolean isChild) {
	match {
		val familiesRegister = retrieve families::FamilyRegister corresponding to newPerson.eContainer
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newPerson.fullName.split(" ").last
		}
		call familiesRegister.families += newFamily
		call insertInExistingFamily(newPerson, newFamily, isChild)
	}
}

routine insertInExistingFamily(persons::Person newPerson, families::Family family, Boolean isChild) {
	action {
		val newMember = create families::Member and initialize {}
		call setMemberFirstName(newMember, newPerson.fullName)
		call {
			if (newPerson instanceof Male) {
				if (isChild) {
					family.sons += newMember
				} else {
					family.father = newMember
				}
			} else {
				if (isChild) {
					family.daughters += newMember
				} else {
					family.mother = newMember
				}
			}
		}
		add correspondence between newPerson and newMember
		add correspondence between newPerson and family
	}
}

/* The fullname of a person changed
 */
reaction ChangedFullName {
	after attribute replaced at persons::Person[fullName]
	call changeNames(affectedEObject)
}
/* Apply firstname changes to the corresponding {@link Member}
 * Apply lastname changes to the corresponding {@link Family}
 */ 
routine changeNames(persons::Person person) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			val String newLastname = person.fullName.split(" ").last
			if (!newLastname.equals(family.lastName)) {
				editLastnameRemovePerson(person, newLastname)
			}
		}
		call setMemberFirstName(member, person.fullName)
	}
}

routine editLastnameRemovePerson(persons::Person person, String fullName) {
	match {
		val family = retrieve families::Family corresponding to person
		val member = retrieve families::Member corresponding to person
	}
	action {
		call {
			//Find out which position the corresponding member had
			var boolean isChild = false
			if (person instanceof Male) {
				isChild = member.familyFather !== family
			} else {
				isChild = member.familyMother !== family
			}
			deleteMember(person)
			insertInNewFamily(person, isChild)
		}
	}
}

routine setMemberFirstName(families::Member member, String fullName) {
	action {
		call {
			val Iterable<String> nameParts = fullName.split(" ")
			var String firstName = null
			if (nameParts.size() == 1) {
				firstName = fullName
			} else {
				firstName = nameParts.take(nameParts.size() - 1).reduce[s1, s2|s1 + " " + s2]
			}
			member.firstName = firstName
		}
	}
}

/* {@link Person} was deleted.
 */
reaction DeletePerson {
	after element persons::Person deleted
	call deleteMember(affectedEObject)
}

/* Delete corresponding {@link Member}.
 */
routine deleteMember(persons::Person person) {
	match {
		val member = retrieve families::Member corresponding to person
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between person and member
		remove correspondence between person and family
		delete member
		call deleteFamilyIfLastMemberWasDeleted(family)
	}
}

/* If deleted {@link Member} was the last one in its {@link Family}, delete family too.
 */
routine deleteFamilyIfLastMemberWasDeleted(families::Family family) {
	match {
		check family.father === null
		check family.mother === null
		check family.sons.empty
		check family.daughters.empty
	}
	action {
		delete family
	}
}

/* Whenever a manipulation of the person model is aborted and changes are discarded,
 * this routine deletes the already inserted {@link Persons} from the {@link PersonRegister}.
 */
routine discardNewPerson(persons::Person newPerson) {
	action {
		call {
			var PersonRegister personRegister = newPerson.eContainer as PersonRegister
			personRegister.persons.^remove(newPerson)
		}
	}
}

