import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers
import java.util.ArrayList
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality
import tools.vitruv.framework.change.echange.feature.reference.ReplaceSingleValuedEReference
import edu.kit.ipd.sdq.metamodels.persons.PersonRegister

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families


reactions: familiesToPersons
in reaction to changes in Families
execute actions in Persons



//========== START CREATION ==========
reaction CreatedFamilyRegister {
	after element families::FamilyRegister created and inserted as root
	call createPersonRegister(newValue)
}

routine createPersonRegister(families::FamilyRegister familyRegister){
	action{
		val personRegister = create persons::PersonRegister and initialize{
			persistProjectRelative(familyRegister, personRegister, "model/persons.persons")
		}
		add correspondence between personRegister and familyRegister 
	}
}

routine replaceFather(families::Member newDad, families::Member oldDad){
	match{
		val personsRegister = retrieve persons::PersonRegister corresponding to newDad.eContainer.eContainer		
	}
	action{
		call{
			println("personsRegister: " + personsRegister)
			deletePerson(oldDad)			
		}
		val newPerson = create persons::Male and initialize {
			newPerson.fullName = newDad.firstName +" "+newDad.familyFather.lastName			
		}
		update personsRegister {
			personsRegister.persons += newPerson;
		}
		add correspondence between newDad and newPerson
		add correspondence between newDad.familyFather and newPerson
	}
}
routine recreateFather(families::Member newDad, families::Member oldDad){
	action{
		call {
			//changes are already applied so we have to reverse them
			//oldDad.familyFather is already null
			//give newDad.familyFather as reference for family to re-insert oldDad
			oldDad.familyFather = newDad.familyFather
			newDad.familyFather = null 
		}
	}
}
routine createFather(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Male and initialize {
			person.fullName = member.firstName + " " + member.familyFather.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyFather and person
	}
}
routine createFatherInDifferentFamily(families::Member newDad, families::Member oldDad){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newDad.eContainer.eContainer		
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action{
		val newFam = create families::Family and initialize {
			newFam.lastName = newDad.familyFather.lastName
		}
		call{
			familyRegister.families += newFam
			oldDad.familyFather = newDad.familyFather 
			newFam.father = newDad
			createFather(newDad)			
		}
	}
}

routine replaceMother(families::Member newMom, families::Member oldMom){
	match{
		val personsRegister = retrieve persons::PersonRegister corresponding to newMom.eContainer.eContainer		
	}
	action{
		call{
			println("personsRegister: " + personsRegister)
			deletePerson(oldMom)			
		}
		val newPerson = create persons::Female and initialize {
			newPerson.fullName = newMom.firstName +" "+newMom.familyMother.lastName			
		}
		update personsRegister {
			personsRegister.persons += newPerson;
		}
		add correspondence between newMom and newPerson
		add correspondence between newMom.familyMother and newPerson
	}
}
routine recreateMother(families::Member newMom, families::Member oldMom){
	action{
		call {
			//changes are already applied so we have to reverse them
			//oldMom.familyMother is already null
			//give newMom.familyMother as reference for family to re-insert oldMom
			oldMom.familyMother = newMom.familyMother
			newMom.familyMother = null 
		}
	}
}
routine createMother(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Female and initialize {
			person.fullName = member.firstName +" "+member.familyMother.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyMother and person
	}
}
routine createMotherInDifferentFamily(families::Member newMom, families::Member oldMom){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newMom.eContainer.eContainer		
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action{
		val newFam = create families::Family and initialize {
			newFam.lastName = newMom.familyMother.lastName
		}
		call{
			familyRegister.families += newFam
			oldMom.familyMother = newMom.familyMother 
			newFam.mother = newMom
			createMother(newMom)			
		}
	}
}


reaction DeletedSon {
	after element families::Member deleted and removed from families::Family[sons] 
	call deletePerson(oldValue)
}
reaction DeletedDaughter {
	after element families::Member deleted and removed from families::Family[daughters] 
	call deletePerson(oldValue)
}

reaction CreatedSon {
	after element families::Member created  and inserted in families::Family[sons]
	call createSon(newValue)
}

routine createSon(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Male and initialize {
			person.fullName = member.firstName +" "+member.familySon.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familySon and person
	}
}



reaction CreatedDaughter {
	after element families::Member created  and inserted in families::Family[daughters]
	call createDaughter(newValue)
}

routine createDaughter(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Female and initialize {
			person.fullName = member.firstName +" "+member.familyDaughter.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyDaughter and person
	}
}
//========== END CREATION ==========
//========== START DELETION ==========
reaction DeletedFamilyRegister{
	after element families::FamilyRegister deleted
	call deletePersonRegister(affectedEObject)
}

routine deletePersonRegister(families::FamilyRegister familyRegister){
	match{
		val personRegister = retrieve persons::PersonRegister corresponding to familyRegister
	}	
	action{
		delete personRegister
	}
}



reaction DeletedFamily {
	after element families::Family deleted
	call deletePersonsOfFamily(affectedEObject)
}

routine deletePersonsOfFamily(families::Family family){
	action {
		call {
			family.members.forEach[deletePerson()]
		}
	}
}

routine deletePerson(families::Member member) {
	match{		
		val person = retrieve persons::Person corresponding to member
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between member and person
		remove correspondence between family and person
		delete person
	}
}
//========== END DELETION ==========

reaction ChangedFirstName {
	after attribute replaced at families::Member[firstName]
	call changeFullNameFromFirst(affectedEObject) 
}

routine changeFullNameFromFirst(families::Member member){
	match {
		val person = retrieve persons::Person corresponding to member
	}
	action {
		update person {
			val family = member.familyFather ?: member.familyMother ?: member.familyDaughter ?: member.familySon
			person.fullName = member.firstName + " " + family.lastName 
			}
	}
}

reaction ChangedLastName {
	after attribute replaced at families::Family[lastName]
	call changeFullNameFromLast(affectedEObject)
}

routine changeFullNameFromLast(families::Family family){
	match {
		val persons = retrieve many persons::Person corresponding to family
	}
	action {
		update persons {
			persons.forEach[x|x.fullName = x.fullName.split(" ").get(0) + " " + family.lastName] 
			}
	}
}

//========== START EDITING ==========
reaction EditedFather {
	after element families::Member replaced at families::Family[father]
	call setFather(newValue, oldValue)
}
routine setFather(families::Member newDad, families::Member oldDad){
	match{
		val newPersonXX = retrieve optional persons::Person corresponding to newDad
		val oldPersonXX = retrieve optional persons::Person corresponding to oldDad		
	}
	action{
		call{
			if(newDad == null){
				if(oldDad == null){
					return
				}
				else{
					//Delete existing father
					deletePerson(oldDad)			
				}
			}
			else{
				val fam = newDad.familyFather
				if(oldDad == null){
					//Create new father since there is no old one
					createFather(newDad)
				}
				else{
					if(newDad.equals(oldDad)){
						//MessageBox "Nothing happend because there was no real change"
						return
					}
					else{
						val String newDadName = newDad.firstName
						val String oldDadName = oldDad.firstName
						val String familyName = fam.lastName	
						var String msg = "You tried to insert a new father, named " + newDadName
						msg += ", into the " + familyName + "-family but there already exists a father named " + oldDadName
						msg += ".\nPlease select one option how this conflict shall be solved."
						val String opt1 = "do nothing"
						val String opt2 = "replace old father"
						val String opt3 = "create new family and add the new dad"				
						var ArrayList<String> options = new ArrayList<String>();
						options.addAll(opt1,opt2,opt3)				
						val int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
						.choices(options).windowModality(WindowModality.MODAL).startInteraction()
//						val int selectedChoice = 2
						switch(selectedChoice){
							case 0:{
								//do nothing
								recreateFather(newDad, oldDad)
								//Nachdem der alte Vater hier widerhergestellt wird, wird noch die Delete-Member-Reaction ausgel�st.
								//Das L�schen muss vermutlich spezifischer sein und auch zwischen Vater, Mutter, Sohn und Tochter unterscheiden	
							}
							case 1:{
								//replace old father
								replaceFather(newDad, oldDad)
//								deletePerson(oldDad)
//								createFather(newDad)
							}
							case 2:{
								//create new family and insert new father there
								createFatherInDifferentFamily(newDad, oldDad)
							}
						}
					}					
				}
			}		
		}
	}
}


reaction EditedMother {
	after element families::Member replaced at families::Family[mother]
	call setMother(newValue, oldValue)
}
routine setMother(families::Member newMom, families::Member oldMom){
	match{
		val newPersonXX = retrieve optional persons::Person corresponding to newMom
		val oldPersonXX = retrieve optional persons::Person corresponding to oldMom		
	}
	action{
		call{
			if(newMom == null){
				if(oldMom == null){
					return
				}
				else{
					//Delete existing mother
					deletePerson(oldMom)			
				}
			}
			else{
				val fam = newMom.familyMother
				if(oldMom == null){
					//Create new mother since there is no old one
					createMother(newMom)
				}
				else{
					if(newMom.equals(oldMom)){
						//MessageBox "Nothing happend because there was no real change"
						return
					}
					else{
						val String newMomName = newMom.firstName
						val String oldMomName = oldMom.firstName
						val String familyName = fam.lastName	
						var String msg = "You tried to insert a new mother, named " + newMomName
						msg += ", into the " + familyName + "-family but there already exists a mother named " + oldMomName
						msg += ".\nPlease select one option how this conflict shall be solved."
						val String opt1 = "do nothing"
						val String opt2 = "replace old mother"
						val String opt3 = "create new family and add the new mother"				
						var ArrayList<String> options = new ArrayList<String>();
						options.addAll(opt1,opt2,opt3)				
						val int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
						.choices(options).windowModality(WindowModality.MODAL).startInteraction()
						switch(selectedChoice){
							case 0:{
								//do nothing
								recreateMother(newMom, oldMom)
								//Nachdem die alte Mutter hier widerhergestellt wird, wird noch die Delete-Member-Reaction ausgeloest.
								//Das Loeschen muss vermutlich spezifischer sein und auch zwischen Vater, Mutter, Sohn und Tochter unterscheiden	
							}
							case 1:{
								//replace old mother
								replaceMother(newMom, oldMom)
							}
							case 2:{
								//create new family and insert new mother there
								createMotherInDifferentFamily(newMom, oldMom)
							}
						}
					}					
				}
			}		
		}
	}
}