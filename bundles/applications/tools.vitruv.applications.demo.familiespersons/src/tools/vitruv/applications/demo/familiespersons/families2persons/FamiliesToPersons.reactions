import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality
import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families


reactions: familiesToPersons
in reaction to changes in Families
execute actions in Persons
 
//========== FAMILY-REGISTER ==========
//Creation of a {@link PersonRegister} after a {@link FamilyRegister} was created.
reaction CreatedFamilyRegister {	
	after element families::FamilyRegister created and inserted as root
	call createPersonRegister(newValue)
}
routine createPersonRegister(families::FamilyRegister familyRegister) {
	action {
		val personRegister = create persons::PersonRegister and initialize {
			persistProjectRelative(familyRegister, personRegister, "model/persons.persons")
		}
		add correspondence between personRegister and familyRegister 
	}
}
//Deletion of a {@link PersonRegister} after a {@link FamilyRegister} was deleted.
reaction DeletedFamilyRegister {
	after element families::FamilyRegister deleted
	call deletePersonRegister(affectedEObject)
}
routine deletePersonRegister(families::FamilyRegister familyRegister) {
	match {
		val personRegister = retrieve persons::PersonRegister corresponding to familyRegister
	}	
	action {
		delete personRegister
	}
}


//========== FAMILY ==========
reaction DeletedFamily {
	after element families::Family deleted
	call deletePersonsOfFamily(affectedEObject)
}
//Delete every family member.
routine deletePersonsOfFamily(families::Family family) {
	action {
		call {
			family.members.forEach[deletePerson()]
		}
	}
}
//Lastname of {@link Family} changed.
reaction ChangedLastName {
	after attribute replaced at families::Family[lastName]
	call changeFullNameFromLast(affectedEObject)
}
//Lastname changed so every {@link Person} corresponding to family is effected.
routine changeFullNameFromLast(families::Family family) {
	match {
		val persons = retrieve many persons::Person corresponding to family
	}
	action {
		update persons {
			persons.forEach[it.fullName = it.fullName.split(" ").get(0) + " " + family.lastName] 
			}
	}
}


//========== FATHER ==========
reaction EditedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue !== null && newValue !== null
	call setFather(newValue, oldValue)
}
reaction CreatedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue === null && newValue !== null
	call createFather(newValue)
}
reaction DeletedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue !== null && newValue === null
	call deletePerson(oldValue)
}
//Old father is about to be replaced by a new father.
routine setFather(families::Member newFather, families::Member oldFather) {
	action{
		call{
			if (!newFather.equals(oldFather)) {
				//The old and the new father are somehow different
				//Ask the user how to proceed...
				var String msg = "You tried to insert a new father, named " + newFather.firstName
				msg += ", into the " + newFather.familyFather.lastName + "-family but "
				msg += "there already exists a father named " + oldFather.firstName
				msg += ".\nPlease select one option how this conflict shall be solved."
								
				val Iterable<String> options = #["discard changes", "replace old father", "insert father into a new family"]
				var int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
				.choices(options).windowModality(WindowModality.MODAL).startInteraction()
				switch (selectedChoice) {
					case 0: {
						//The user wants to discard changes,
						//but the replacement already took place.						
						//-> Revert changes.
						recreateFather(newFather, oldFather)							
					}
					case 1: {
						//replace old father
						replaceFather(newFather, oldFather)
					}
					case 2: {
						//create new family and insert new father there
						createFatherInDifferentFamily(newFather, oldFather)
					}
				}					
			}					
		}
	}
}
//Delete Person corresponding to oldFather.
//Create and insert new person corresponding to newFather. 
routine replaceFather(families::Member newFather, families::Member oldFather) {
	match {		 
		val personsRegister = retrieve persons::PersonRegister corresponding to newFather.familyFather.eContainer		
	}
	action {
		call {
			deletePerson(oldFather)			
		}
		val newPerson = create persons::Male and initialize {
			newPerson.fullName = newFather.firstName + " " + newFather.familyFather.lastName			
		}
		update personsRegister {
			personsRegister.persons += newPerson;
		}
		add correspondence between newFather and newPerson
		add correspondence between newFather.familyFather and newPerson
	}
}
//Reverse already made changes in case of a "discard changes" reaction to naming conflicts.
routine recreateFather(families::Member newFather, families::Member oldFather) {
	action {
		call {
			//oldFather.familyFather is already null
			//give newFather.familyFather as reference for family to re-insert oldFather
			oldFather.familyFather = newFather.familyFather
			newFather.familyFather = null 
		}
	}
}
//Create and insert new person corresponding to newFather. 
routine createFather(families::Member newFather) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newFather.familyFather.eContainer 
	}
	action{
		val person = create persons::Male and initialize {
			person.fullName = newFather.firstName + " " + newFather.familyFather.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between newFather and person
		add correspondence between newFather.familyFather and person
	}
}
//Recreate oldFather and moving newFather into a new family. 
routine createFatherInDifferentFamily(families::Member newFather, families::Member oldFather) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newFather.familyFather.eContainer		
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {
		//Create new family with identical lastname
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newFather.familyFather.lastName
		}
		call {			
			familyRegister.families += newFamily
			//Get old father back into old family.
			oldFather.familyFather = newFather.familyFather
			//Move newFather into new family.
			newFamily.father = newFather
			//Create and insert new person corresponding to newFather.
			createFather(newFather)			
		}
	}
}


//========== MOTHER ==========
reaction EditedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue !== null && newValue !== null
	call setMother(newValue, oldValue)
}
reaction CreatedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue === null && newValue !== null
	call createMother(newValue)
}

reaction DeletedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue !== null && newValue === null
	call deletePerson(oldValue)
}


//Old mother is about to be replaced by a new mother.
routine setMother(families::Member newMother, families::Member oldMother) {
	action {
		call {
			if (!newMother.equals(oldMother)) {
				//The old and the new mother are somehow different
				//Ask the user how to proceed...
				var String msg = "You tried to insert a new mother, named " + newMother.firstName
				msg += ", into the " + newMother.familyMother.lastName + "-family but "
				msg += "there already exists a mother named " + oldMother.firstName
				msg += ".\nPlease select one option how this conflict shall be solved."
								
				val Iterable<String> options = #["discard changes", "replace old mother", "insert mother into a new family"]										
				var int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
				.choices(options).windowModality(WindowModality.MODAL).startInteraction()
				switch (selectedChoice) {
					case 0: {
						//The user wants to discard changes,
						//but the replacement already took place.						
						//-> Revert changes.
						recreateMother(newMother, oldMother)	
					}
					case 1: {
						//replace old mother
						replaceMother(newMother, oldMother)
					}
					case 2: {
						//create new family and insert new mother there
						createMotherInDifferentFamily(newMother, oldMother)
					}
				}
			}
		}
	}
}
//Delete Person corresponding to oldMother.
//Create and insert new person corresponding to newMother.
routine replaceMother(families::Member newMother, families::Member oldMother) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newMother.familyMother.eContainer		
	}
	action {
		call {
			deletePerson(oldMother)			
		}
		val newPerson = create persons::Female and initialize {
			newPerson.fullName = newMother.firstName + " " + newMother.familyMother.lastName			
		}
		update personsRegister {
			personsRegister.persons += newPerson;
		}
		add correspondence between newMother and newPerson
		add correspondence between newMother.familyMother and newPerson
	}
}
//Reverse already made changes in case of a "discard changes" reaction to naming conflicts.
routine recreateMother(families::Member newMother, families::Member oldMother) {
	action {
		call {
			//oldMother.familyMother is already null
			//give newMother.familyMother as reference for family to re-insert oldMother
			oldMother.familyMother = newMother.familyMother
			newMother.familyMother = null 
		}
	}
}
//Create and insert new person corresponding to newMother.
routine createMother(families::Member newMother) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newMother.familyMother.eContainer 
	}
	action {
		val person = create persons::Female and initialize {
			person.fullName = newMother.firstName + " " + newMother.familyMother.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between newMother and person
		add correspondence between newMother.familyMother and person
	}
}
//Recreate oldMother and moving newMother into a new family.
routine createMotherInDifferentFamily(families::Member newMother, families::Member oldMother) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newMother.familyMother.eContainer		
		val familyRegister = retrieve families::FamilyRegister corresponding to personsRegister
	}
	action {			
		//Create new family with identical lastname
		val newFamily = create families::Family and initialize {
			newFamily.lastName = newMother.familyMother.lastName
		}
		call {
			familyRegister.families += newFamily
			//Get old mother back into old family.
			oldMother.familyMother = newMother.familyMother
			//Move newMother into new family. 
			newFamily.mother = newMother
			//Create and insert new person corresponding to newMother.
			createMother(newMother)			
		}
	}
}


//========== SON ==========
reaction CreatedSon {
	after element families::Member created  and inserted in families::Family[sons]
	call createSon(newValue)
}
routine createSon(families::Member newSon) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newSon.familySon.eContainer 
	}
	action {
		val person = create persons::Male and initialize {
			person.fullName = newSon.firstName + " " + newSon.familySon.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between newSon and person
		add correspondence between newSon.familySon and person
	}
}
reaction DeletedSon {
	after element families::Member deleted and removed from families::Family[sons] 
	call deletePerson(oldValue)
}


//========== DAUGHTER ==========
reaction CreatedDaughter {
	after element families::Member created  and inserted in families::Family[daughters]
	call createDaughter(newValue)
}
routine createDaughter(families::Member newDaughter) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newDaughter.familyDaughter.eContainer 
	}
	action{
		val person = create persons::Female and initialize {
			person.fullName = newDaughter.firstName + " " + newDaughter.familyDaughter.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between newDaughter and person
		add correspondence between newDaughter.familyDaughter and person
	}
}
reaction DeletedDaughter {
	after element families::Member deleted and removed from families::Family[daughters] 
	call deletePerson(oldValue)
}


//========== MEMBER IN GENERAL ==========
//Firstname of {@link Member} changed.
reaction ChangedFirstName {
	after attribute replaced at families::Member[firstName]
	call changeFullNameFromFirst(affectedEObject) 
}
//Firstname changed so only the corresponding {@link Person} is effected.
routine changeFullNameFromFirst(families::Member member) {
	match {
		val person = retrieve persons::Person corresponding to member
	}
	action {
		update person {
			val family = member.familyFather ?: member.familyMother ?: member.familyDaughter ?: member.familySon
			person.fullName = member.firstName + " " + family.lastName 
		}
	}
}
routine deletePerson(families::Member member) {
	match {		
		val person = retrieve persons::Person corresponding to member
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between member and person
		remove correspondence between family and person
		delete person
	}
}
