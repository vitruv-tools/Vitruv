import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers
import edu.kit.ipd.sdq.metamodels.families.FamilyRegister
import java.util.Collection
import java.util.ArrayList
import edu.kit.ipd.sdq.metamodels.families.Member
import java.util.List

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families

reactions: familiesToPersons
in reaction to changes in Families
execute actions in Persons
 
//========== FAMILY-REGISTER ==========
//Creation of a {@link PersonRegister} after a {@link FamilyRegister} was created.
reaction CreatedFamilyRegister {
	after element families::FamilyRegister created and inserted as root
	call createPersonRegister(newValue)
}
routine createPersonRegister(families::FamilyRegister familyRegister) {
	action {
		val personRegister = create persons::PersonRegister and initialize {
			persistProjectRelative(familyRegister, personRegister, "model/persons.persons")
		}
		add correspondence between personRegister and familyRegister
	}
}
//Deletion of a {@link PersonRegister} after a {@link FamilyRegister} was deleted.
reaction DeletedFamilyRegister {
	after element families::FamilyRegister deleted
	call deletePersonRegister(affectedEObject)
}
routine deletePersonRegister(families::FamilyRegister familyRegister) {
	match {
		val personRegister = retrieve persons::PersonRegister corresponding to familyRegister
	}	
	action {
		delete personRegister
	}
}


//========== FAMILY ==========
reaction DeletedFamily {
	after element families::Family deleted
	call deletePersonsOfFamily(affectedEObject)
}
//Delete every family member.
routine deletePersonsOfFamily(families::Family family) {
	action {
		call {
			family.members.forEach[deletePerson()]
		}
	}
}
//Lastname of {@link Family} changed.
reaction ChangedLastName {
	after attribute replaced at families::Family[lastName]
	call changeFullNameFromLast(affectedEObject)
}
//Lastname changed so every {@link Person} corresponding to family is effected.
routine changeFullNameFromLast(families::Family family) {
	match {
		val persons = retrieve many persons::Person corresponding to family
	}
	action {
		call {
			val Collection<Member> membersToRename = new ArrayList<Member>
			if (family.father !== null) {
				membersToRename.^add(family.father)
			}
			if (family.mother !== null) {
				membersToRename.^add(family.mother)
			}
			membersToRename.addAll(family.sons)
			membersToRename.addAll(family.daughters)
			membersToRename.forEach[updatePersonName(it)]
		}
	}
}

//========== FATHER ==========
reaction EditedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue !== null && newValue !== null && !oldValue.equals(newValue)
	call {
		moveOldFatherToNewFamily(oldValue, affectedEObject)
		createMale(newValue, affectedEObject)
	}
}
reaction CreatedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue === null && newValue !== null
	call createMale(newValue, affectedEObject)
}
reaction DeletedFather {
	after element families::Member replaced at families::Family[father]
		with oldValue !== null && newValue === null
	call deletePerson(oldValue)
}

routine moveOldFatherToNewFamily(families::Member oldFather, families::Family oldFamily) {
	match {
		val oldFatherPerson = retrieve persons::Person corresponding to oldFather
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = oldFamily.lastName
			newFamily.father = oldFather
		}
		call {
			val FamilyRegister familyRegister = oldFamily.eContainer as FamilyRegister
			familyRegister.families += newFamily 
		}
		remove correspondence between oldFamily and oldFatherPerson
		add correspondence between newFamily and oldFatherPerson		
	}
}


//========== MOTHER ==========
reaction EditedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue !== null && newValue !== null && !oldValue.equals(newValue) 
	call {
		moveOldMotherToNewFamily(oldValue, affectedEObject)
		createFemale(newValue, affectedEObject)
	}
}
reaction CreatedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue === null && newValue !== null
	call createFemale(newValue, affectedEObject)
}

reaction DeletedMother {
	after element families::Member replaced at families::Family[mother]
		with oldValue !== null && newValue === null
	call deletePerson(oldValue)
}

routine moveOldMotherToNewFamily(families::Member oldMother, families::Family oldFamily) {
	match {
		val oldMotherPerson = retrieve persons::Person corresponding to oldMother
	}
	action {
		val newFamily = create families::Family and initialize {
			newFamily.lastName = oldFamily.lastName
			newFamily.mother = oldMother
		}
		call {
			val FamilyRegister familyRegister = oldFamily.eContainer as FamilyRegister
			familyRegister.families += newFamily 
		}
		remove correspondence between oldFamily and oldMotherPerson
		add correspondence between newFamily and oldMotherPerson		
	}
}

//========== SON ==========
reaction CreatedSon {
	after element families::Member created and inserted in families::Family[sons]
	call createMale(newValue, affectedEObject)
}
reaction DeletedSon {
	after element families::Member deleted and removed from families::Family[sons] 
	call deletePerson(oldValue)
}


//========== DAUGHTER ==========
reaction CreatedDaughter {
	after element families::Member created and inserted in families::Family[daughters]
	call createFemale(newValue, affectedEObject)
}
reaction DeletedDaughter {
	after element families::Member deleted and removed from families::Family[daughters] 
	call deletePerson(oldValue)
}


routine createMale(families::Member newMember, families::Family family) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to family.eContainer 
	}
	action {
		val person = create persons::Male and initialize {
	 		person.fullName = newMember.firstName + " " + family.lastName
		}		
		update personsRegister {
			personsRegister.persons += person
		}
		add correspondence between newMember and person
		add correspondence between family and person
	}
}
routine createFemale(families::Member newMember, families::Family family) {
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to family.eContainer 
	}
	action {
		val person = create persons::Female and initialize {
	 		person.fullName = newMember.firstName + " " + family.lastName
		}		
		update personsRegister {
			personsRegister.persons += person
		}
		add correspondence between newMember and person
		add correspondence between family and person
	}
}

//========== MEMBER IN GENERAL ==========
//Firstname of {@link Member} changed.
reaction ChangedFirstName {
	after attribute replaced at families::Member[firstName]
	call updatePersonName(affectedEObject) 
}
//Firstname changed so only the corresponding {@link Person} is effected.
routine updatePersonName(families::Member member) {
	match {
		val person = retrieve persons::Person corresponding to member
	}
	action {
		update person {
			val family = member.familyFather ?: member.familyMother ?: member.familyDaughter ?: member.familySon
			person.fullName = member.firstName + " " + family.lastName 
		}		
	}
}

routine deletePerson(families::Member member) {
	match {		
		val person = retrieve persons::Person corresponding to member
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between member and person
		remove correspondence between family and person
		delete person
	}
}
