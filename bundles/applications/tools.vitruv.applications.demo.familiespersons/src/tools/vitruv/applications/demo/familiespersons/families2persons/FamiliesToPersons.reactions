import static extension tools.vitruv.domains.demo.families.FamiliesUtil.getMembers
import java.util.ArrayList
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality
import tools.vitruv.framework.change.echange.feature.reference.ReplaceSingleValuedEReference

import "edu.kit.ipd.sdq.metamodels.persons" as persons
import "edu.kit.ipd.sdq.metamodels.families" as families


reactions: familiesToPersons
in reaction to changes in Families
execute actions in Persons



//========== START CREATION ==========
reaction CreatedFamilyRegister {
	after element families::FamilyRegister created and inserted as root
	call createPersonRegister(newValue)
}

routine createPersonRegister(families::FamilyRegister familyRegister){
	action{
		val personRegister = create persons::PersonRegister and initialize{
			persistProjectRelative(familyRegister, personRegister, "model/persons.persons")
		}
		add correspondence between personRegister and familyRegister 
	}
}








routine replaceFather(families::Member newDad, families::Member oldDad){
	match{
//		val newPerson = retrieve persons::Person corresponding to newDad
//		val newFamily = retrieve families::Family corresponding to newPerson
//		val oldPerson = retrieve persons::Person corresponding to oldDad
//		val oldFamily = retrieve families::Family corresponding to oldPerson
		val personsRegister = retrieve persons::PersonRegister corresponding to newDad.eContainer.eContainer		
	}
	action{
		call{
//			println("newPerson: " + newPerson)
//			println("newFamily: " + newFamily)
//			println("oldPerson: " + oldPerson)
//			println("oldFamily: " + oldFamily)
			println("personsRegister: " + personsRegister)
			deletePerson(newDad)			
		}
		val newPerson2 = create persons::Male and initialize {
			newPerson2.fullName = newDad.firstName +" "+newDad.familyFather.lastName			
		}
		update personsRegister {
//			personsRegister.persons -= oldPerson;
			personsRegister.persons += newPerson2;
		}
//		remove correspondence between newDad.familyFather and oldPerson
//		delete oldPerson
		add correspondence between newDad.familyFather and newPerson2
	}
}
routine recreateFather(families::Member newDad, families::Member oldDad){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to newDad.eContainer.eContainer 
	}
	action{
		call {
			//changes are already applied so we have to reverse them
			//oldDad.familyFather is already null
			//give newDad.familyFather as reference for family to re-insert oldDad
			oldDad.familyFather = newDad.familyFather
			newDad.familyFather = null 
		}
		val person = create persons::Male and initialize {
			person.fullName = oldDad.firstName +" "+oldDad.familyFather.lastName			
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between oldDad.familyFather and person
	}
}
routine createFather(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Male and initialize {
			person.fullName = member.firstName +" "+member.familyFather.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyFather and person
	}
}
routine createMother(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Female and initialize {
			person.fullName = member.firstName +" "+member.familyMother.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyMother and person
	}
}


routine createFatherInDifferentFamily(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val newFam = create families::Family and initialize {
			newFam.lastName = member.familyFather.lastName + "_2" 			
		}
		call{
			member.familyFather = newFam			
		}
		val person = create persons::Male and initialize {
			person.fullName = member.firstName +" "+member.familyFather.lastName			
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyFather and person
	}
}

//routine createNewFamily()...

//routine createMother(families::Member member){
//	match {
//		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
//	}
//	action{
//		val person = create persons::Female and initialize {
//			person.fullName = member.firstName +" "+member.familyMother.lastName
//		}
//		update personsRegister {
//			personsRegister.persons += person;
//		}
//		add correspondence between member and person
//		add correspondence between member.familyMother and person
//	}
//}

reaction DeletedSon {
	after element families::Member deleted and removed from families::Family[sons] 
	call deletePerson(oldValue)
}
reaction DeletedDaughter {
	after element families::Member deleted and removed from families::Family[daughters] 
	call deletePerson(oldValue)
}

reaction CreatedSon {
	after element families::Member created  and inserted in families::Family[sons]
	call createSon(newValue)
}

routine createSon(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Male and initialize {
			person.fullName = member.firstName +" "+member.familySon.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familySon and person
	}
}



reaction CreatedDaughter {
	after element families::Member created  and inserted in families::Family[daughters]
	call createDaughter(newValue)
}

routine createDaughter(families::Member member){
	match {
		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
	}
	action{
		val person = create persons::Female and initialize {
			person.fullName = member.firstName +" "+member.familyDaughter.lastName
		}
		update personsRegister {
			personsRegister.persons += person;
		}
		add correspondence between member and person
		add correspondence between member.familyDaughter and person
	}
}
//========== END CREATION ==========
//========== START DELETION ==========
reaction DeletedFamilyRegister{
	after element families::FamilyRegister deleted
	call deletePersonRegister(affectedEObject)
}

routine deletePersonRegister(families::FamilyRegister familyRegister){
	match{
		val personRegister = retrieve persons::PersonRegister corresponding to familyRegister
	}	
	action{
		delete personRegister
	}
}



reaction DeletedFamily {
	after element families::Family deleted
	call deletePersonsOfFamily(affectedEObject)
}

routine deletePersonsOfFamily(families::Family family){
	action {
		call {
			family.members.forEach[deletePerson()]
		}
	}
}



//reaction DeletedMember {
//	after element families::Member deleted 
//	call deletePerson(affectedEObject)
//}

routine deletePerson(families::Member member) {
	match{		
		val person = retrieve persons::Person corresponding to member
		val family = retrieve families::Family corresponding to person
	}
	action {
		remove correspondence between member and person
		remove correspondence between family and person
		delete person
	}
}
//========== END DELETION ==========

reaction ChangedFirstName {
	after attribute replaced at families::Member[firstName]
	call changeFullNameFromFirst(affectedEObject) 
}

routine changeFullNameFromFirst(families::Member member){
	match {
		val person = retrieve persons::Person corresponding to member
	}
	action {
		update person {
			val family = member.familyFather ?: member.familyMother ?: member.familyDaughter ?: member.familySon
			person.fullName = member.firstName + " " + family.lastName 
			}
	}
}

reaction ChangedLastName {
	after attribute replaced at families::Family[lastName]
	call changeFullNameFromLast(affectedEObject)
}

routine changeFullNameFromLast(families::Family family){
	match {
		//Sollten mehrere sein
//		val person = retrieve persons::Person corresponding to family
		val persons = retrieve many persons::Person corresponding to family
	}
	action {
		update persons {
			persons.forEach[x|x.fullName = x.fullName.split(" ").get(0) + " " + family.lastName] 
			}
	}
}

//reaction EditedFather1 {
//	after element families::Member replaced at families::Family[father]
//	call s()
//}
//reaction EditedFather2 {
//	after element families::Member replaced at families::Family[father]
//	call s()
//}
//routine s(){
//	action{
//		call{
//			if(true){
//				return			
//			}			
//		}
//	}
//}
//========== START EDITING ==========
reaction EditedFather {
	after element families::Member replaced at families::Family[father]
	call setFather(newValue, oldValue)
}
routine setFather(families::Member newDad, families::Member oldDad){
	match{
		val newPersonXX = retrieve optional persons::Person corresponding to newDad
		val oldPersonXX = retrieve optional persons::Person corresponding to oldDad		
//		val newFamilyXX = retrieve optional families::Family corresponding to newPersonXX
//		val oldFamilyXX = retrieve optional families::Family corresponding to oldPersonXX
	}
	action{
		call{
			if(newDad == null){
				if(oldDad == null){
					return
				}
				else{
					//Delete existing father
					deletePerson(oldDad)			
				}
			}
			else{
				val fam = newDad.familyFather
				if(oldDad == null){
					//Create new father since there is no old one
					createFather(newDad)
				}
				else{
					if(newDad.equals(oldDad)){
						//MessageBox "Nothing happend because there was no real change"
						return
					}
					else{
						val String newDadName = newDad.firstName
						val String oldDadName = oldDad.firstName
						val String familyName = fam.lastName	
						var String msg = "You tried to insert a new father, named " + newDadName
						msg += ", into the " + familyName + "-family but there already exists a father named " + oldDadName
						msg += ".\nPlease select one option how this conflict shall be solved."
						val String opt1 = "do nothing"
						val String opt2 = "replace old father"
						val String opt3 = "create new family and add the new dad"				
						var ArrayList<String> options = new ArrayList<String>();
						options.addAll(opt1,opt2,opt3)				
						val int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
						.choices(options).windowModality(WindowModality.MODAL).startInteraction()
//						val int selectedChoice = 2
						switch(selectedChoice){
							case 0:{
								//do nothing
								recreateFather(newDad, oldDad)
								//Nachdem der alte Vater hier widerhergestellt wird, wird noch die Delete-Member-Reaction ausgelöst.
								//Das Löschen muss vermutlich spezifischer sein und auch zwischen Vater, Mutter, Sohn und Tochter unterscheiden	
							}
							case 1:{
								//replace old father
								replaceFather(newDad, oldDad)
//								deletePerson(oldDad)
//								createFather(newDad)
							}
							case 2:{
								//create new family and insert new father there
								createFatherInDifferentFamily(newDad)
							}
						}
					}					
				}
			}		
		}
	}
}


reaction EditedMother {
	after element families::Member replaced at families::Family[mother]
	call setMother(newValue, oldValue)
}
routine setMother(families::Member newMom, families::Member oldMom){
	match{
		val newPersonXX = retrieve optional persons::Person corresponding to newMom
		val oldPersonXX = retrieve optional persons::Person corresponding to oldMom		
//		val newFamilyXX = retrieve optional families::Family corresponding to newPersonXX
//		val oldFamilyXX = retrieve optional families::Family corresponding to oldPersonXX
	}
	action{
		call{
			if(newMom == null){
				if(oldMom == null){
					return
				}
				else{
					//Delete existing father
					deletePerson(oldMom)			
				}
			}
			else{
				val fam = newMom.familyFather
				if(oldMom == null){
					//Create new father since there is no old one
					createMother(newMom)
				}
				else{
					if(true) return;
					if(newMom.equals(oldMom)){
						//MessageBox "Nothing happend because there was no real change"
						return
					}
					else{
						val String newMomName = newMom.firstName
						val String oldMomName = oldMom.firstName
						val String familyName = fam.lastName	
						var String msg = "You tried to insert a new father, named " + newMomName
						msg += ", into the " + familyName + "-family but there already exists a father named " + oldMomName
						msg += ".\nPlease select one option how this conflict shall be solved."
						val String opt1 = "do nothing"
						val String opt2 = "replace old father"
						val String opt3 = "create new family and add the new mom"				
						var ArrayList<String> options = new ArrayList<String>();
						options.addAll(opt1,opt2,opt3)				
						val int selectedChoice = userInteractor.singleSelectionDialogBuilder.message(msg)
						.choices(options).windowModality(WindowModality.MODAL).startInteraction()
//						val int selectedChoice = 2
						switch(selectedChoice){
							case 0:{
								//do nothing
								recreateFather(newMom, oldMom)
								//Nachdem der alte Vater hier widerhergestellt wird, wird noch die Delete-Member-Reaction ausgelöst.
								//Das Löschen muss vermutlich spezifischer sein und auch zwischen Vater, Mutter, Sohn und Tochter unterscheiden	
							}
							case 1:{
								//replace old father
								replaceFather(newMom, oldMom)
//								deletePerson(oldMom)
//								createFather(newMom)
							}
							case 2:{
								//create new family and insert new father there
								createFatherInDifferentFamily(newMom)
							}
						}
					}					
				}
			}		
		}
	}
}

//routine createOrReplaceFather(families::Member member) {
//	match{
//		val personsRegister = retrieve persons::PersonRegister corresponding to member.eContainer.eContainer 
//		val person = retrieve persons::Person corresponding to member
//		val family = retrieve families::Family corresponding to person		
//	}
//	action{
//		call{
//			val String newDadName = member.firstName
//			if()
//			
//			val String oldDadName = family.father.firstName
//			val String familyName = family.lastName	
//			var String msg = "You tried to insert a new , named " + newDadName
//			msg += ", into the " + familyName + "-family but there already exists a father named " + oldDadName
//			msg += ".\nPlease select one option how this conflict shall be solved."			
//			userInteractor.singleSelectionDialogBuilder.message(msg)
//			createFather(member)			
//		}		
//	}
//}
//========== END EDITING ==========