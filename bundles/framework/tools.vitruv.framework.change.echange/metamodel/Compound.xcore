@Ecore(nsURI="http://tools.vitruv/EChange/Compound/1.0")
@GenModel(modelName="Change") //@GenModel(editDirectory="/tools.vitruv.framework.change.echange.edit/src", editorDirectory="/tools.vitruv.framework.change.echange.editor/src", modelName="Change", modelPluginClass="", editPluginClass="tools.vitruv.framework.change.provider.ChangeEditPlugin", editorPluginClass="tools.vitruv.framework.change.echange.presentation.ChangeEditorPlugin", testsDirectory="tools.vitruv.framework.change.echange.tests/src", testSuiteClass="tools.vitruv.framework.change.echange.tests.ChangeAllTests", importerID="org.eclipse.emf.importer.ecore", editorPluginID="tools.vitruv.framework.change.echange.editor", testsPluginID="tools.vitruv.framework.change.echange.tests")
package tools.vitruv.framework.change.echange.compound

//import org.eclipse.emf.common.command.Command
//import org.eclipse.emf.common.util.BasicEList
//import org.eclipse.emf.ecore.EAttribute
//import org.eclipse.emf.ecore.EObject
//import org.eclipse.emf.ecore.EReference
//import org.eclipse.emf.ecore.EStructuralFeature
//import org.eclipse.emf.ecore.resource.ResourceSet
//import tools.vitruv.framework.change.echange.AdditiveEChange
//import tools.vitruv.framework.change.echange.AtomicEChange
//import tools.vitruv.framework.change.echange.EChange
//import tools.vitruv.framework.change.echange.SubtractiveEChange
//import tools.vitruv.framework.change.echange.eobject.CreateEObject
//import tools.vitruv.framework.change.echange.eobject.DeleteEObject
//import tools.vitruv.framework.change.echange.eobject.EObjectAddedEChange
//import tools.vitruv.framework.change.echange.eobject.EObjectSubtractedEChange
//import tools.vitruv.framework.change.echange.feature.attribute.SubtractiveAttributeEChange
//import tools.vitruv.framework.change.echange.feature.reference.InsertEReference
//import tools.vitruv.framework.change.echange.feature.reference.RemoveEReference
//import tools.vitruv.framework.change.echange.feature.reference.ReplaceSingleValuedEReference
//import tools.vitruv.framework.change.echange.feature.reference.UpdateReferenceEChange
//import tools.vitruv.framework.change.echange.resolve.EChangeResolver
//import tools.vitruv.framework.change.echange.root.InsertRootEObject
//import tools.vitruv.framework.change.echange.root.RemoveRootEObject
//
//type Command wraps Command
//type ResourceSet wraps ResourceSet
//type EObj wraps EObject
//
///**
// * Abstract EChange which is a sequence of several atomic changes.
// */
//abstract class CompoundEChange extends tools.vitruv.framework.change.echange.EChange {
//	/**
//	 * Returns the atomic changes of the compound changes, in the same order as they are 
//	 * resolved / applied.
//	 */
//	op unique AtomicEChange[+] getAtomicChanges()
//	
//	/**
//	 * Returns if all proxy EObjects of the change are resolved to concrete EObjects of a resource set.
//	 * Needs to be true to apply the change.
//	 * @return	All proxy EObjects are resolved to concrete EObjects.
//	 */	
//	op boolean isResolved() {
//		for (AtomicEChange change : getAtomicChanges()) {
//			if (!change.isResolved()) {
//				return false
//			}
//		}
//		return super.isResolved()
//	}	
//	
//	/**
//	 * Resolves the compound change like {@link resolveBefore}, but also applies the change forward.
//	 * If the change was already resolved, it returns the original change and applies it forward.
//	 * @param resourceSet 				The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
//	 * 									the unresolved should be resolved to.
//	 * @return 							Returns the resolved change if the change could be applied forward. The returned change
//	 * 									is a copy of the change or, if the change was already resolved, the original change. 
//	 * 									If the change could not be resolved and / or applied or the 
//	 * 									resource set is {@code null}, it returns {@code null}
//	 * @throws IllegalStateException 	The change is already resolved.
//	 */
//	op EChange resolveBeforeAndApplyForward(ResourceSet resourceSet) {
//		return EChangeResolver.resolveCopy(this, resourceSet, true, false)	
//	}
//
//	/**
//	 * Resolves the compound change like {@link resolveAfter}, but also applies the change backward.
//	 * If the change was already resolved, it returns the original change and applies it backward.
//	 * @param resourceSet 				The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
//	 * 									the unresolved should be resolved to.
//	 * @return 							Returns the resolved change if the change could be applied backward. The returned change
//	 * 									is a copy of the change or, if the change was already resolved, the original change. 
//	 * 									If the change could not be resolved and / or applied or the resource set is {@code null}, 
//	 * 									it returns {@code null}
//	 * @throws IllegalStateException 	The change is already resolved.
//	 */	
//	op EChange resolveAfterAndApplyBackward(ResourceSet resourceSet) {
//		return EChangeResolver.resolveCopy(this, resourceSet, false, false)
//	}
//}
//
///**
// * 
// */
//class MoveEObject<A extends EObj, B extends EObj, T extends EObj> extends CompoundEChange {
//	refers UpdateReferenceEChange<A> subtractWhereChange
//	contains EObjectSubtractedEChange<T>[1] subtractWhatChange
//	refers UpdateReferenceEChange<B> addWhereChange
//	contains EObjectAddedEChange<T>[1] addWhatChange
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val list = new BasicEList<AtomicEChange>();
//		val subWhereChange = getSubtractWhereChange();
//		if (subWhereChange != null) {
//			list.add(subWhereChange);
//		}
//		list.add(getSubtractWhatChange());
//		val addWhereChange = getAddWhereChange();
//		if (addWhereChange != null) {
//		    list.add(addWhereChange);
//		}
//		list.add(getAddWhatChange());
//		
//		return list;
//		
//	}
//}
//
///**
// * Abstract EChange which unsets a single or many valued feature.
// */
//abstract class ExplicitUnsetEFeature<A extends EObj, F extends EStructuralFeature> extends CompoundEChange {
//	refers A[1] affectedEObject
//	refers F[1] affectedFeature
//}
//
///**
// * EChange which unsets a single or many valued attribute.
// */
//class ExplicitUnsetEAttribute<A extends EObj, T extends Object> extends CompoundSubtraction<T, SubtractiveAttributeEChange<A,T>>, ExplicitUnsetEFeature<A, EAttribute> {
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList<AtomicEChange>();
//		result.addAll(subtractiveChanges);
//		return result;
//	}
//}
//
///**
// * EChange which unsets a single or many valued reference.
// */
//class ExplicitUnsetEReference<A extends EObj> extends ExplicitUnsetEFeature<A, EReference> {
//	contains EChange[+] changes
//	/**
//	 * Returns the changes this unset consists of. Can also be compound changes, e.g., a RemoveAndDeleteNonRoot
//	 */
//	op unique EChange[+] getContainedChanges() {
//		return changes;
//	}
//	op unique AtomicEChange[+] getAtomicChanges() {
//		changes.map[
//			if (it instanceof AtomicEChange) 
//				#[it] 
//			else if (it instanceof CompoundEChange) 
//				it.atomicChanges 
//			else 
//				throw new IllegalArgumentException
//		].flatten.asEList
//	}
//}
//
///** 
// * EChange which replaces an EObject in an EList.
// */
////class ReplaceInEList<A extends EObj, F extends EStructuralFeature, T extends EObj, R extends RemoveFromListEChange<A, F, T> & FeatureEChange<A, F> & SubtractiveEChange<T>, I extends InsertInListEChange<A, F, T> & FeatureEChange<A, F> & AdditiveEChange<T>> extends CompoundEChange {
////	contains R[1] removeChange
////	contains I[1] insertChange
////	op unique AtomicEChange[+] getAtomicChanges() {
////		val list = new BasicEList<AtomicEChange>();
////		list.add(getRemoveChange());
////		list.add(getInsertChange());
////		return list;
////	}
////}
//
///**
// * Abstract change which combines several subtractive EChanges of the same type.
// */
//abstract class CompoundSubtraction<T extends Object, S extends SubtractiveEChange<T>> extends CompoundEChange {
//	contains S[+] subtractiveChanges
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList<AtomicEChange>();
//		result.addAll(subtractiveChanges);
//		return result;
//	}
//}
//
///**
// * Abstract change which combines several additive EChanges of the same type.
// */
//abstract class CompoundAddition<T extends Object, S extends AdditiveEChange<T>> extends CompoundEChange {
//	contains S[+] additiveChanges
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList<AtomicEChange>();
//		result.addAll(additiveChanges);
//		return result;
//	}
//}
//
//
///** 
// *  Abstract EChange which creates a new EObject and inserts it in a reference. 
// */
//abstract class CreateAndInsertEObject<T extends EObj, C extends EObjectAddedEChange<T>> extends CompoundEChange {
//	contains CreateEObject<T>[1] createChange
//	contains C[1] insertChange
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList();
//		result.add(createChange);
//		result.add(insertChange);
//		return result;
//	}
//}
//
//
///**
// * Abstract EChange which removes an EObject from a reference and deletes it.
// */
//abstract class RemoveAndDeleteEObject<T extends EObj, C extends EObjectSubtractedEChange<T>> extends CompoundEChange {
//	contains C[1] removeChange
//	contains DeleteEObject<T>[1] deleteChange
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList();
//		result.add(removeChange);
//		result.add(deleteChange);
//		return result;
//	}
//}
//
//
///** 
// * EChange which creates and inserts a new root EObject in a resource.
// */
//class CreateAndInsertRoot<T extends EObj> extends CreateAndInsertEObject<T, InsertRootEObject<T>> {}
//
//
///**
// * EChange which removes an existing EObject from a resource and deletes it.
// */
//class RemoveAndDeleteRoot<T extends EObj> extends RemoveAndDeleteEObject<T, RemoveRootEObject<T>> {}
//
//
///**
// * EChange which creates and inserts a new EObject into a containment reference. 
// */
//class CreateAndInsertNonRoot<A extends EObj, T extends EObj> extends CreateAndInsertEObject<T, InsertEReference<A, T>> {}
//
//
///**
// * EChange which removes an existing EObject from a many valued containment reference and deletes it.
// */
//class RemoveAndDeleteNonRoot<A extends EObj, T extends EObj> extends RemoveAndDeleteEObject<T, RemoveEReference<A, T>> {}
//
///**
// * EChange which creates a new EObject and replaces null in a single valued reference.
// */
//class CreateAndReplaceNonRoot<A extends EObj, T extends EObj> extends CreateAndInsertEObject<T, ReplaceSingleValuedEReference<A, T>> {}
//
///**
// * EChange which replaces an existing EObject with null in a single valued reference and deletes it.
// */
//class ReplaceAndDeleteNonRoot<A extends EObj, T extends EObj> extends RemoveAndDeleteEObject<T, ReplaceSingleValuedEReference<A, T>> {}
//
///**
// * EChange creates a new EObject and replaces an existing one in a single valued containment reference. The old one will be deleted.
// */
//class CreateAndReplaceAndDeleteNonRoot<A extends EObj, T extends EObj> extends CompoundEChange {
//	contains CreateEObject<T>[1] createChange
//	contains ReplaceSingleValuedEReference<A, T>[1] replaceChange
//	contains DeleteEObject<T>[1] deleteChange
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val result = new BasicEList();
//		result.add(createChange);
//		result.add(replaceChange);
//		result.add(deleteChange);
//		return result;
//	}
//}
