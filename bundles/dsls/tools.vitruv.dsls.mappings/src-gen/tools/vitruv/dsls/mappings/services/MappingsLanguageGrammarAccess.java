/*
 * generated by Xtext 2.12.0
 */
package tools.vitruv.dsls.mappings.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.xbase.services.XbaseGrammarAccess;
import org.eclipse.xtext.xbase.services.XtypeGrammarAccess;
import tools.vitruv.dsls.mirbase.services.MirBaseGrammarAccess;

@Singleton
public class MappingsLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MappingsFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.MappingsFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamespaceImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamespaceImportsXImportSectionParserRuleCall_0_0 = (RuleCall)cNamespaceImportsAssignment_0.eContents().get(0);
		private final RuleCall cMirBaseFileParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cMappingsSegmentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMappingsSegmentsMappingsSegmentParserRuleCall_2_0 = (RuleCall)cMappingsSegmentsAssignment_2.eContents().get(0);
		
		//MappingsFile:
		//	namespaceImports=XImportSection?
		//	MirBaseFile
		//	mappingsSegments+=MappingsSegment+;
		@Override public ParserRule getRule() { return rule; }
		
		//namespaceImports=XImportSection? MirBaseFile mappingsSegments+=MappingsSegment+
		public Group getGroup() { return cGroup; }
		
		//namespaceImports=XImportSection?
		public Assignment getNamespaceImportsAssignment_0() { return cNamespaceImportsAssignment_0; }
		
		//XImportSection
		public RuleCall getNamespaceImportsXImportSectionParserRuleCall_0_0() { return cNamespaceImportsXImportSectionParserRuleCall_0_0; }
		
		//MirBaseFile
		public RuleCall getMirBaseFileParserRuleCall_1() { return cMirBaseFileParserRuleCall_1; }
		
		//mappingsSegments+=MappingsSegment+
		public Assignment getMappingsSegmentsAssignment_2() { return cMappingsSegmentsAssignment_2; }
		
		//MappingsSegment
		public RuleCall getMappingsSegmentsMappingsSegmentParserRuleCall_2_0() { return cMappingsSegmentsMappingsSegmentParserRuleCall_2_0; }
	}
	public class MappingsSegmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.MappingsSegment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDocumentableParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cMappingsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameValidIDParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cForKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLeftDomainAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLeftDomainDomainReferenceParserRuleCall_4_0 = (RuleCall)cLeftDomainAssignment_4.eContents().get(0);
		private final Keyword cAndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cRightDomainAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRightDomainDomainReferenceParserRuleCall_6_0 = (RuleCall)cRightDomainAssignment_6.eContents().get(0);
		private final Alternatives cAlternatives_7 = (Alternatives)cGroup.eContents().get(7);
		private final Assignment cMappingsAssignment_7_0 = (Assignment)cAlternatives_7.eContents().get(0);
		private final RuleCall cMappingsMappingParserRuleCall_7_0_0 = (RuleCall)cMappingsAssignment_7_0.eContents().get(0);
		private final Assignment cBootstrappingsAssignment_7_1 = (Assignment)cAlternatives_7.eContents().get(1);
		private final RuleCall cBootstrappingsBootstrappingParserRuleCall_7_1_0 = (RuleCall)cBootstrappingsAssignment_7_1.eContents().get(0);
		
		//MappingsSegment:
		//	Documentable
		//	'mappings:' name=ValidID
		//	'for' leftDomain=DomainReference
		//	'and' rightDomain=DomainReference (mappings+=Mapping | bootstrappings+=Bootstrapping)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Documentable 'mappings:' name=ValidID 'for' leftDomain=DomainReference 'and' rightDomain=DomainReference
		//(mappings+=Mapping | bootstrappings+=Bootstrapping)*
		public Group getGroup() { return cGroup; }
		
		//Documentable
		public RuleCall getDocumentableParserRuleCall_0() { return cDocumentableParserRuleCall_0; }
		
		//'mappings:'
		public Keyword getMappingsKeyword_1() { return cMappingsKeyword_1; }
		
		//name=ValidID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ValidID
		public RuleCall getNameValidIDParserRuleCall_2_0() { return cNameValidIDParserRuleCall_2_0; }
		
		//'for'
		public Keyword getForKeyword_3() { return cForKeyword_3; }
		
		//leftDomain=DomainReference
		public Assignment getLeftDomainAssignment_4() { return cLeftDomainAssignment_4; }
		
		//DomainReference
		public RuleCall getLeftDomainDomainReferenceParserRuleCall_4_0() { return cLeftDomainDomainReferenceParserRuleCall_4_0; }
		
		//'and'
		public Keyword getAndKeyword_5() { return cAndKeyword_5; }
		
		//rightDomain=DomainReference
		public Assignment getRightDomainAssignment_6() { return cRightDomainAssignment_6; }
		
		//DomainReference
		public RuleCall getRightDomainDomainReferenceParserRuleCall_6_0() { return cRightDomainDomainReferenceParserRuleCall_6_0; }
		
		//(mappings+=Mapping | bootstrappings+=Bootstrapping)*
		public Alternatives getAlternatives_7() { return cAlternatives_7; }
		
		//mappings+=Mapping
		public Assignment getMappingsAssignment_7_0() { return cMappingsAssignment_7_0; }
		
		//Mapping
		public RuleCall getMappingsMappingParserRuleCall_7_0_0() { return cMappingsMappingParserRuleCall_7_0_0; }
		
		//bootstrappings+=Bootstrapping
		public Assignment getBootstrappingsAssignment_7_1() { return cBootstrappingsAssignment_7_1; }
		
		//Bootstrapping
		public RuleCall getBootstrappingsBootstrappingParserRuleCall_7_1_0() { return cBootstrappingsBootstrappingParserRuleCall_7_1_0; }
	}
	public class MappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.Mapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMappingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameValidIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDependsOnKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDependenciesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDependenciesDependencyParserRuleCall_2_1_0 = (RuleCall)cDependenciesAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cMapKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cLeftParametersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cLeftParametersClassicallyNamedModelElementParserRuleCall_5_0 = (RuleCall)cLeftParametersAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cWithKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cLeftConditionsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cLeftConditionsSingleSidedConditionParserRuleCall_7_1_0 = (RuleCall)cLeftConditionsAssignment_7_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Keyword cAndKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cRightParametersAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cRightParametersClassicallyNamedModelElementParserRuleCall_9_0 = (RuleCall)cRightParametersAssignment_9.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cWithKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cRightConditionsAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cRightConditionsSingleSidedConditionParserRuleCall_11_1_0 = (RuleCall)cRightConditionsAssignment_11_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_11_2 = (Keyword)cGroup_11.eContents().get(2);
		private final Group cGroup_12 = (Group)cGroup.eContents().get(12);
		private final Keyword cSuchThatKeyword_12_0 = (Keyword)cGroup_12.eContents().get(0);
		private final Assignment cBidirectionalizableConditionsAssignment_12_1 = (Assignment)cGroup_12.eContents().get(1);
		private final RuleCall cBidirectionalizableConditionsBidirectionalizableConditionParserRuleCall_12_1_0 = (RuleCall)cBidirectionalizableConditionsAssignment_12_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_12_2 = (Keyword)cGroup_12.eContents().get(2);
		private final Group cGroup_13 = (Group)cGroup.eContents().get(13);
		private final Keyword cForwardExecuteKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final Assignment cForwardExecutionExpressionAssignment_13_1 = (Assignment)cGroup_13.eContents().get(1);
		private final RuleCall cForwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_1_0 = (RuleCall)cForwardExecutionExpressionAssignment_13_1.eContents().get(0);
		private final Keyword cBackwardExecuteKeyword_13_2 = (Keyword)cGroup_13.eContents().get(2);
		private final Assignment cBackwardExecutionExpressionAssignment_13_3 = (Assignment)cGroup_13.eContents().get(3);
		private final RuleCall cBackwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_3_0 = (RuleCall)cBackwardExecutionExpressionAssignment_13_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_13_4 = (Keyword)cGroup_13.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_14 = (Keyword)cGroup.eContents().get(14);
		
		///******************/ /* BEGIN MAPPINGS */ /******************/ Mapping:
		//	'mapping' name=ValidID ('depends on ('
		//	dependencies+=Dependency
		//	')')?
		//	'{'
		//	'map (' leftParameters+=ClassicallyNamedModelElement+ ')' ('with {'
		//	leftConditions+=SingleSidedCondition+
		//	'}')?
		//	'and (' rightParameters+=ClassicallyNamedModelElement+ ')' ('with {'
		//	rightConditions+=SingleSidedCondition+
		//	'}')? ('such that {'
		//	bidirectionalizableConditions+=BidirectionalizableCondition+
		//	'}')? ('forward execute {'
		//	forwardExecutionExpression=UnidirectionalExpression
		//	'} backward execute {'
		//	backwardExecutionExpression=UnidirectionalExpression
		//	'}')?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'mapping' name=ValidID ('depends on (' dependencies+=Dependency ')')? '{' 'map ('
		//leftParameters+=ClassicallyNamedModelElement+ ')' ('with {' leftConditions+=SingleSidedCondition+ '}')? 'and ('
		//rightParameters+=ClassicallyNamedModelElement+ ')' ('with {' rightConditions+=SingleSidedCondition+ '}')?
		//('such that {' bidirectionalizableConditions+=BidirectionalizableCondition+ '}')? ('forward execute {'
		//forwardExecutionExpression=UnidirectionalExpression '} backward execute {'
		//backwardExecutionExpression=UnidirectionalExpression '}')? '}'
		public Group getGroup() { return cGroup; }
		
		//'mapping'
		public Keyword getMappingKeyword_0() { return cMappingKeyword_0; }
		
		//name=ValidID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ValidID
		public RuleCall getNameValidIDParserRuleCall_1_0() { return cNameValidIDParserRuleCall_1_0; }
		
		//('depends on (' dependencies+=Dependency ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'depends on ('
		public Keyword getDependsOnKeyword_2_0() { return cDependsOnKeyword_2_0; }
		
		//dependencies+=Dependency
		public Assignment getDependenciesAssignment_2_1() { return cDependenciesAssignment_2_1; }
		
		//Dependency
		public RuleCall getDependenciesDependencyParserRuleCall_2_1_0() { return cDependenciesDependencyParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'map ('
		public Keyword getMapKeyword_4() { return cMapKeyword_4; }
		
		//leftParameters+=ClassicallyNamedModelElement+
		public Assignment getLeftParametersAssignment_5() { return cLeftParametersAssignment_5; }
		
		//ClassicallyNamedModelElement
		public RuleCall getLeftParametersClassicallyNamedModelElementParserRuleCall_5_0() { return cLeftParametersClassicallyNamedModelElementParserRuleCall_5_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
		
		//('with {' leftConditions+=SingleSidedCondition+ '}')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'with {'
		public Keyword getWithKeyword_7_0() { return cWithKeyword_7_0; }
		
		//leftConditions+=SingleSidedCondition+
		public Assignment getLeftConditionsAssignment_7_1() { return cLeftConditionsAssignment_7_1; }
		
		//SingleSidedCondition
		public RuleCall getLeftConditionsSingleSidedConditionParserRuleCall_7_1_0() { return cLeftConditionsSingleSidedConditionParserRuleCall_7_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7_2() { return cRightCurlyBracketKeyword_7_2; }
		
		//'and ('
		public Keyword getAndKeyword_8() { return cAndKeyword_8; }
		
		//rightParameters+=ClassicallyNamedModelElement+
		public Assignment getRightParametersAssignment_9() { return cRightParametersAssignment_9; }
		
		//ClassicallyNamedModelElement
		public RuleCall getRightParametersClassicallyNamedModelElementParserRuleCall_9_0() { return cRightParametersClassicallyNamedModelElementParserRuleCall_9_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_10() { return cRightParenthesisKeyword_10; }
		
		//('with {' rightConditions+=SingleSidedCondition+ '}')?
		public Group getGroup_11() { return cGroup_11; }
		
		//'with {'
		public Keyword getWithKeyword_11_0() { return cWithKeyword_11_0; }
		
		//rightConditions+=SingleSidedCondition+
		public Assignment getRightConditionsAssignment_11_1() { return cRightConditionsAssignment_11_1; }
		
		//SingleSidedCondition
		public RuleCall getRightConditionsSingleSidedConditionParserRuleCall_11_1_0() { return cRightConditionsSingleSidedConditionParserRuleCall_11_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_11_2() { return cRightCurlyBracketKeyword_11_2; }
		
		//('such that {' bidirectionalizableConditions+=BidirectionalizableCondition+ '}')?
		public Group getGroup_12() { return cGroup_12; }
		
		//'such that {'
		public Keyword getSuchThatKeyword_12_0() { return cSuchThatKeyword_12_0; }
		
		//bidirectionalizableConditions+=BidirectionalizableCondition+
		public Assignment getBidirectionalizableConditionsAssignment_12_1() { return cBidirectionalizableConditionsAssignment_12_1; }
		
		//BidirectionalizableCondition
		public RuleCall getBidirectionalizableConditionsBidirectionalizableConditionParserRuleCall_12_1_0() { return cBidirectionalizableConditionsBidirectionalizableConditionParserRuleCall_12_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_12_2() { return cRightCurlyBracketKeyword_12_2; }
		
		//('forward execute {' forwardExecutionExpression=UnidirectionalExpression '} backward execute {'
		//backwardExecutionExpression=UnidirectionalExpression '}')?
		public Group getGroup_13() { return cGroup_13; }
		
		//'forward execute {'
		public Keyword getForwardExecuteKeyword_13_0() { return cForwardExecuteKeyword_13_0; }
		
		//forwardExecutionExpression=UnidirectionalExpression
		public Assignment getForwardExecutionExpressionAssignment_13_1() { return cForwardExecutionExpressionAssignment_13_1; }
		
		//UnidirectionalExpression
		public RuleCall getForwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_1_0() { return cForwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_1_0; }
		
		//'} backward execute {'
		public Keyword getBackwardExecuteKeyword_13_2() { return cBackwardExecuteKeyword_13_2; }
		
		//backwardExecutionExpression=UnidirectionalExpression
		public Assignment getBackwardExecutionExpressionAssignment_13_3() { return cBackwardExecutionExpressionAssignment_13_3; }
		
		//UnidirectionalExpression
		public RuleCall getBackwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_3_0() { return cBackwardExecutionExpressionUnidirectionalExpressionParserRuleCall_13_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_13_4() { return cRightCurlyBracketKeyword_13_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_14() { return cRightCurlyBracketKeyword_14; }
	}
	public class DependencyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.Dependency");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMappingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cMappingMappingCrossReference_0_0 = (CrossReference)cMappingAssignment_0.eContents().get(0);
		private final RuleCall cMappingMappingIDTerminalRuleCall_0_0_1 = (RuleCall)cMappingMappingCrossReference_0_0.eContents().get(1);
		private final Assignment cShortNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortNameValidIDParserRuleCall_1_0 = (RuleCall)cShortNameAssignment_1.eContents().get(0);
		
		//// DW: RequiredMapping
		//Dependency:
		//	mapping=[Mapping] shortName=ValidID;
		@Override public ParserRule getRule() { return rule; }
		
		//mapping=[Mapping] shortName=ValidID
		public Group getGroup() { return cGroup; }
		
		//mapping=[Mapping]
		public Assignment getMappingAssignment_0() { return cMappingAssignment_0; }
		
		//[Mapping]
		public CrossReference getMappingMappingCrossReference_0_0() { return cMappingMappingCrossReference_0_0; }
		
		//ID
		public RuleCall getMappingMappingIDTerminalRuleCall_0_0_1() { return cMappingMappingIDTerminalRuleCall_0_0_1; }
		
		//shortName=ValidID
		public Assignment getShortNameAssignment_1() { return cShortNameAssignment_1; }
		
		//ValidID
		public RuleCall getShortNameValidIDParserRuleCall_1_0() { return cShortNameValidIDParserRuleCall_1_0; }
	}
	public class SingleSidedConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.SingleSidedCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnforceableConditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCheckAndEnforceConditionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SingleSidedCondition:
		//	EnforceableCondition | CheckAndEnforceCondition;
		@Override public ParserRule getRule() { return rule; }
		
		//// returns Condition:
		//EnforceableCondition | CheckAndEnforceCondition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//// returns Condition:
		//EnforceableCondition
		public RuleCall getEnforceableConditionParserRuleCall_0() { return cEnforceableConditionParserRuleCall_0; }
		
		//CheckAndEnforceCondition
		public RuleCall getCheckAndEnforceConditionParserRuleCall_1() { return cCheckAndEnforceConditionParserRuleCall_1; }
	}
	public class EnforceableConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.EnforceableCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFeatureConditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cResourceConditionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///* BEGIN ENFORCEABLE CONDITIONS */ EnforceableCondition:
		//	FeatureCondition | ResourceCondition;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns SingleSidedCondition:
		//FeatureCondition | ResourceCondition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////  returns SingleSidedCondition:
		//FeatureCondition
		public RuleCall getFeatureConditionParserRuleCall_0() { return cFeatureConditionParserRuleCall_0; }
		
		//ResourceCondition
		public RuleCall getResourceConditionParserRuleCall_1() { return cResourceConditionParserRuleCall_1; }
	}
	public class FeatureConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.FeatureCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cSingleValueConditionParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cMultiValueConditionParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cElementConditionParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cNotEmptyConditionParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Assignment cFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFeatureMetaclassFeatureReferenceParserRuleCall_1_0 = (RuleCall)cFeatureAssignment_1.eContents().get(0);
		
		//FeatureCondition:
		//	(SingleValueCondition | MultiValueCondition | ElementCondition | NotEmptyCondition) feature=MetaclassFeatureReference;
		@Override public ParserRule getRule() { return rule; }
		
		//(SingleValueCondition | MultiValueCondition | ElementCondition | NotEmptyCondition) feature=MetaclassFeatureReference
		public Group getGroup() { return cGroup; }
		
		////  returns EnforceableCondition:
		//SingleValueCondition | MultiValueCondition | ElementCondition | NotEmptyCondition
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//SingleValueCondition
		public RuleCall getSingleValueConditionParserRuleCall_0_0() { return cSingleValueConditionParserRuleCall_0_0; }
		
		//MultiValueCondition
		public RuleCall getMultiValueConditionParserRuleCall_0_1() { return cMultiValueConditionParserRuleCall_0_1; }
		
		//ElementCondition
		public RuleCall getElementConditionParserRuleCall_0_2() { return cElementConditionParserRuleCall_0_2; }
		
		//NotEmptyCondition
		public RuleCall getNotEmptyConditionParserRuleCall_0_3() { return cNotEmptyConditionParserRuleCall_0_3; }
		
		//feature=MetaclassFeatureReference
		public Assignment getFeatureAssignment_1() { return cFeatureAssignment_1; }
		
		//MetaclassFeatureReference
		public RuleCall getFeatureMetaclassFeatureReferenceParserRuleCall_1_0() { return cFeatureMetaclassFeatureReferenceParserRuleCall_1_0; }
	}
	public class FeatureReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.FeatureReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDependentFeatureReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Action cMetaclassFeatureReferenceAction_1 = (Action)cAlternatives.eContents().get(1);
		
		//FeatureReference:
		//	DependentFeatureReference | {MetaclassFeatureReference};
		@Override public ParserRule getRule() { return rule; }
		
		//DependentFeatureReference | {MetaclassFeatureReference}
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DependentFeatureReference
		public RuleCall getDependentFeatureReferenceParserRuleCall_0() { return cDependentFeatureReferenceParserRuleCall_0; }
		
		//{MetaclassFeatureReference}
		public Action getMetaclassFeatureReferenceAction_1() { return cMetaclassFeatureReferenceAction_1; }
	}
	public class DependentFeatureReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.DependentFeatureReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDependeeShortNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDependeeShortNameDependencyCrossReference_0_0 = (CrossReference)cDependeeShortNameAssignment_0.eContents().get(0);
		private final RuleCall cDependeeShortNameDependencyValidIDParserRuleCall_0_0_1 = (RuleCall)cDependeeShortNameDependencyCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDependeeFeatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDependeeFeatureMetaclassFeatureReferenceParserRuleCall_2_0 = (RuleCall)cDependeeFeatureAssignment_2.eContents().get(0);
		
		//// DW: FeatureOfContextVariable
		//DependentFeatureReference:
		//	dependeeShortName=[Dependency|ValidID]
		//	':'
		//	dependeeFeature=MetaclassFeatureReference;
		@Override public ParserRule getRule() { return rule; }
		
		//dependeeShortName=[Dependency|ValidID] ':' dependeeFeature=MetaclassFeatureReference
		public Group getGroup() { return cGroup; }
		
		//dependeeShortName=[Dependency|ValidID]
		public Assignment getDependeeShortNameAssignment_0() { return cDependeeShortNameAssignment_0; }
		
		//[Dependency|ValidID]
		public CrossReference getDependeeShortNameDependencyCrossReference_0_0() { return cDependeeShortNameDependencyCrossReference_0_0; }
		
		//ValidID
		public RuleCall getDependeeShortNameDependencyValidIDParserRuleCall_0_0_1() { return cDependeeShortNameDependencyValidIDParserRuleCall_0_0_1; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//dependeeFeature=MetaclassFeatureReference
		public Assignment getDependeeFeatureAssignment_2() { return cDependeeFeatureAssignment_2; }
		
		//MetaclassFeatureReference
		public RuleCall getDependeeFeatureMetaclassFeatureReferenceParserRuleCall_2_0() { return cDependeeFeatureMetaclassFeatureReferenceParserRuleCall_2_0; }
	}
	public class SingleValueConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.SingleValueCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIndexConditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumCompareConditionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SingleValueCondition:
		//	IndexCondition | NumCompareCondition;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns ValueCondition:
		//IndexCondition | NumCompareCondition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////  returns ValueCondition:
		//IndexCondition
		public RuleCall getIndexConditionParserRuleCall_0() { return cIndexConditionParserRuleCall_0; }
		
		//NumCompareCondition
		public RuleCall getNumCompareConditionParserRuleCall_1() { return cNumCompareConditionParserRuleCall_1; }
	}
	public class ValueConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.ValueCondition");
		private final Assignment cValueExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueExpressionValueExpressionParserRuleCall_0 = (RuleCall)cValueExpressionAssignment.eContents().get(0);
		
		//ValueCondition:
		//	valueExpression=ValueExpression;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns FeatureCondition:
		//valueExpression=ValueExpression
		public Assignment getValueExpressionAssignment() { return cValueExpressionAssignment; }
		
		//ValueExpression
		public RuleCall getValueExpressionValueExpressionParserRuleCall_0() { return cValueExpressionValueExpressionParserRuleCall_0; }
	}
	public class ValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.ValueExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		//ValueExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class IndexConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.IndexCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNegatedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNegatedNotKeyword_0_0 = (Keyword)cNegatedAssignment_0.eContents().get(0);
		private final Keyword cAtIndexKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIndexValueExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexValueExpressionValueExpressionParserRuleCall_2_0 = (RuleCall)cIndexValueExpressionAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//IndexCondition:
		//	negated?='not'
		//	'at index'
		//	indexValueExpression=ValueExpression
		//	'in';
		@Override public ParserRule getRule() { return rule; }
		
		////  returns SingleValueCondition:
		//negated?='not' 'at index' indexValueExpression=ValueExpression 'in'
		public Group getGroup() { return cGroup; }
		
		////  returns SingleValueCondition:
		//negated?='not'
		public Assignment getNegatedAssignment_0() { return cNegatedAssignment_0; }
		
		//'not'
		public Keyword getNegatedNotKeyword_0_0() { return cNegatedNotKeyword_0_0; }
		
		//'at index'
		public Keyword getAtIndexKeyword_1() { return cAtIndexKeyword_1; }
		
		//indexValueExpression=ValueExpression
		public Assignment getIndexValueExpressionAssignment_2() { return cIndexValueExpressionAssignment_2; }
		
		//ValueExpression
		public RuleCall getIndexValueExpressionValueExpressionParserRuleCall_2_0() { return cIndexValueExpressionValueExpressionParserRuleCall_2_0; }
		
		//'in'
		public Keyword getInKeyword_3() { return cInKeyword_3; }
	}
	public class NumCompareConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.NumCompareCondition");
		private final Assignment cOperatorAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOperatorNumCompareOperatorEnumRuleCall_0 = (RuleCall)cOperatorAssignment.eContents().get(0);
		
		//NumCompareCondition:
		//	operator=NumCompareOperator;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns SingleValueCondition:
		//operator=NumCompareOperator
		public Assignment getOperatorAssignment() { return cOperatorAssignment; }
		
		//NumCompareOperator
		public RuleCall getOperatorNumCompareOperatorEnumRuleCall_0() { return cOperatorNumCompareOperatorEnumRuleCall_0; }
	}
	public class MultiValueConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.MultiValueCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNegatedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNegatedNotKeyword_0_0 = (Keyword)cNegatedAssignment_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorMultiValueConditionOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		
		///*
		//NumCompareOperator returns SingleValueConditionOperator:
		//	NotGreaterOperator |
		//	LessOperator |
		//	NotLessOperator |
		//	GreaterOperator
		//;
		//
		//NotGreaterOperator returns NumCompareOperator: '<=';
		//
		//LessOperator returns NumCompareOperator: '<';
		//
		//NotLessOperator returns NumCompareOperator: '>=';
		//
		//GreaterOperator returns NumCompareOperator: '>';
		//*/ MultiValueCondition:
		//	negated?='not'
		//	operator=MultiValueConditionOperator;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns FeatureCondition:
		//negated?='not' operator=MultiValueConditionOperator
		public Group getGroup() { return cGroup; }
		
		////  returns FeatureCondition:
		//negated?='not'
		public Assignment getNegatedAssignment_0() { return cNegatedAssignment_0; }
		
		//'not'
		public Keyword getNegatedNotKeyword_0_0() { return cNegatedNotKeyword_0_0; }
		
		//operator=MultiValueConditionOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }
		
		//MultiValueConditionOperator
		public RuleCall getOperatorMultiValueConditionOperatorEnumRuleCall_1_0() { return cOperatorMultiValueConditionOperatorEnumRuleCall_1_0; }
	}
	public class ElementConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.ElementCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cElementExpressionElementExpressionParserRuleCall_0_0 = (RuleCall)cElementExpressionAssignment_0.eContents().get(0);
		private final Keyword cDefaultContainedInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ElementCondition:
		//	elementExpression=ElementExpression
		//	'default contained in';
		@Override public ParserRule getRule() { return rule; }
		
		////  returns FeatureCondition:
		//elementExpression=ElementExpression 'default contained in'
		public Group getGroup() { return cGroup; }
		
		////  returns FeatureCondition:
		//elementExpression=ElementExpression
		public Assignment getElementExpressionAssignment_0() { return cElementExpressionAssignment_0; }
		
		//ElementExpression
		public RuleCall getElementExpressionElementExpressionParserRuleCall_0_0() { return cElementExpressionElementExpressionParserRuleCall_0_0; }
		
		//'default contained in'
		public Keyword getDefaultContainedInKeyword_1() { return cDefaultContainedInKeyword_1; }
	}
	public class ElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.ElementExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		//ElementExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class NotEmptyConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.NotEmptyCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNegatedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNegatedNotKeyword_0_0 = (Keyword)cNegatedAssignment_0.eContents().get(0);
		private final Keyword cEmptyKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NotEmptyCondition:
		//	negated?='not'
		//	'empty';
		@Override public ParserRule getRule() { return rule; }
		
		////  returns FeatureCondition:
		//negated?='not' 'empty'
		public Group getGroup() { return cGroup; }
		
		////  returns FeatureCondition:
		//negated?='not'
		public Assignment getNegatedAssignment_0() { return cNegatedAssignment_0; }
		
		//'not'
		public Keyword getNegatedNotKeyword_0_0() { return cNegatedNotKeyword_0_0; }
		
		//'empty'
		public Keyword getEmptyKeyword_1() { return cEmptyKeyword_1; }
	}
	public class ResourceConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.ResourceCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultPathForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementExpressionElementExpressionParserRuleCall_1_0 = (RuleCall)cElementExpressionAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cPathOfKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cPathExpressionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cPathExpressionElementExpressionParserRuleCall_3_1_0 = (RuleCall)cPathExpressionAssignment_3_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cPathAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPathSTRINGTerminalRuleCall_4_0 = (RuleCall)cPathAssignment_4.eContents().get(0);
		
		//ResourceCondition: //  returns EnforceableCondition:
		//	'default path for' elementExpression=ElementExpression '=' ('path of' pathExpression=ElementExpression "+")?
		//	path=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns EnforceableCondition:
		//'default path for' elementExpression=ElementExpression '=' ('path of' pathExpression=ElementExpression "+")? path=STRING
		public Group getGroup() { return cGroup; }
		
		////  returns EnforceableCondition:
		//'default path for'
		public Keyword getDefaultPathForKeyword_0() { return cDefaultPathForKeyword_0; }
		
		//elementExpression=ElementExpression
		public Assignment getElementExpressionAssignment_1() { return cElementExpressionAssignment_1; }
		
		//ElementExpression
		public RuleCall getElementExpressionElementExpressionParserRuleCall_1_0() { return cElementExpressionElementExpressionParserRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//('path of' pathExpression=ElementExpression "+")?
		public Group getGroup_3() { return cGroup_3; }
		
		//'path of'
		public Keyword getPathOfKeyword_3_0() { return cPathOfKeyword_3_0; }
		
		//pathExpression=ElementExpression
		public Assignment getPathExpressionAssignment_3_1() { return cPathExpressionAssignment_3_1; }
		
		//ElementExpression
		public RuleCall getPathExpressionElementExpressionParserRuleCall_3_1_0() { return cPathExpressionElementExpressionParserRuleCall_3_1_0; }
		
		//"+"
		public Keyword getPlusSignKeyword_3_2() { return cPlusSignKeyword_3_2; }
		
		//path=STRING
		public Assignment getPathAssignment_4() { return cPathAssignment_4; }
		
		//STRING
		public RuleCall getPathSTRINGTerminalRuleCall_4_0() { return cPathSTRINGTerminalRuleCall_4_0; }
	}
	public class CheckAndEnforceConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.CheckAndEnforceCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCheckKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCheckExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCheckExpressionCheckExpressionParserRuleCall_1_0 = (RuleCall)cCheckExpressionAssignment_1.eContents().get(0);
		private final Keyword cEnforceKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEnforceExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEnforceExpressionCheckExpressionParserRuleCall_3_0 = (RuleCall)cEnforceExpressionAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		///* END ENFORCEABLE CONDITIONS */ /* BEGIN CHECK AND ENFORCE CONDITION*/ CheckAndEnforceCondition: //  returns SingleSidedCondition:
		//	'check {' checkExpression=CheckExpression '}
		//	enforce {' enforceExpression=CheckExpression '}';
		@Override public ParserRule getRule() { return rule; }
		
		////  returns SingleSidedCondition:
		//'check {' checkExpression=CheckExpression '}
		//	enforce {' enforceExpression=CheckExpression '}'
		public Group getGroup() { return cGroup; }
		
		////  returns SingleSidedCondition:
		//'check {'
		public Keyword getCheckKeyword_0() { return cCheckKeyword_0; }
		
		//checkExpression=CheckExpression
		public Assignment getCheckExpressionAssignment_1() { return cCheckExpressionAssignment_1; }
		
		//CheckExpression
		public RuleCall getCheckExpressionCheckExpressionParserRuleCall_1_0() { return cCheckExpressionCheckExpressionParserRuleCall_1_0; }
		
		//'}
		//	enforce {'
		public Keyword getEnforceKeyword_2() { return cEnforceKeyword_2; }
		
		//enforceExpression=CheckExpression
		public Assignment getEnforceExpressionAssignment_3() { return cEnforceExpressionAssignment_3; }
		
		//CheckExpression
		public RuleCall getEnforceExpressionCheckExpressionParserRuleCall_3_0() { return cEnforceExpressionCheckExpressionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class CheckExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.CheckExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		//CheckExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class EnforceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.EnforceExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		//EnforceExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class BidirectionalizableConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.BidirectionalizableCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFeatureToBeAssignedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFeatureToBeAssignedMetaclassFeatureReferenceParserRuleCall_0_0 = (RuleCall)cFeatureToBeAssignedAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBidirectionalizableExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBidirectionalizableExpressionBidirectionalizableExpressionParserRuleCall_2_0 = (RuleCall)cBidirectionalizableExpressionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cUpdateKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFeatureToBeUpdatedAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFeatureToBeUpdatedMetaclassFeatureReferenceParserRuleCall_3_1_0 = (RuleCall)cFeatureToBeUpdatedAssignment_3_1.eContents().get(0);
		
		///* END CHECK AND ENFORCE CONDITION */ /* BEGIN BIDIRECTIONALIZABLE CONDITION */ BidirectionalizableCondition:
		//	featureToBeAssigned=MetaclassFeatureReference
		//	'='
		//	bidirectionalizableExpression=BidirectionalizableExpression ('update' featureToBeUpdated=MetaclassFeatureReference)?;
		@Override public ParserRule getRule() { return rule; }
		
		////  returns Condition:
		//featureToBeAssigned=MetaclassFeatureReference '=' bidirectionalizableExpression=BidirectionalizableExpression ('update'
		//featureToBeUpdated=MetaclassFeatureReference)?
		public Group getGroup() { return cGroup; }
		
		////  returns Condition:
		//featureToBeAssigned=MetaclassFeatureReference
		public Assignment getFeatureToBeAssignedAssignment_0() { return cFeatureToBeAssignedAssignment_0; }
		
		//MetaclassFeatureReference
		public RuleCall getFeatureToBeAssignedMetaclassFeatureReferenceParserRuleCall_0_0() { return cFeatureToBeAssignedMetaclassFeatureReferenceParserRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//bidirectionalizableExpression=BidirectionalizableExpression
		public Assignment getBidirectionalizableExpressionAssignment_2() { return cBidirectionalizableExpressionAssignment_2; }
		
		//BidirectionalizableExpression
		public RuleCall getBidirectionalizableExpressionBidirectionalizableExpressionParserRuleCall_2_0() { return cBidirectionalizableExpressionBidirectionalizableExpressionParserRuleCall_2_0; }
		
		//('update' featureToBeUpdated=MetaclassFeatureReference)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'update'
		public Keyword getUpdateKeyword_3_0() { return cUpdateKeyword_3_0; }
		
		//featureToBeUpdated=MetaclassFeatureReference
		public Assignment getFeatureToBeUpdatedAssignment_3_1() { return cFeatureToBeUpdatedAssignment_3_1; }
		
		//MetaclassFeatureReference
		public RuleCall getFeatureToBeUpdatedMetaclassFeatureReferenceParserRuleCall_3_1_0() { return cFeatureToBeUpdatedMetaclassFeatureReferenceParserRuleCall_3_1_0; }
	}
	public class BidirectionalizableExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.BidirectionalizableExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		//BidirectionalizableExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class UnidirectionalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.UnidirectionalExpression");
		private final Action cCodeBlockAction = (Action)rule.eContents().get(1);
		
		///* END BIDIRECTIONALIZABLE CONDITION */ UnidirectionalExpression:
		//	{CodeBlock};
		@Override public ParserRule getRule() { return rule; }
		
		//{CodeBlock}
		public Action getCodeBlockAction() { return cCodeBlockAction; }
	}
	public class BootstrappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.Bootstrapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBootstrappingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameValidIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cCreateKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParametersClassicallyNamedModelElementParserRuleCall_4_0 = (RuleCall)cParametersAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cWithKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cBootstrapConditonAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cBootstrapConditonSingleSidedConditionParserRuleCall_6_1_0 = (RuleCall)cBootstrapConditonAssignment_6_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		///******************/ /* END MAPPINGS */ /******************/ /***************************/ /* BEGIN BOOTSTRAPPING */
		///***************************/ Bootstrapping:
		//	'bootstrapping' name=ValidID
		//	'{'
		//	'create (' parameters+=ClassicallyNamedModelElement+ ')' ('with {'
		//	bootstrapConditon=SingleSidedCondition
		//	'}')?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'bootstrapping' name=ValidID '{' 'create (' parameters+=ClassicallyNamedModelElement+ ')' ('with {'
		//bootstrapConditon=SingleSidedCondition '}')? '}'
		public Group getGroup() { return cGroup; }
		
		//'bootstrapping'
		public Keyword getBootstrappingKeyword_0() { return cBootstrappingKeyword_0; }
		
		//name=ValidID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ValidID
		public RuleCall getNameValidIDParserRuleCall_1_0() { return cNameValidIDParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//'create ('
		public Keyword getCreateKeyword_3() { return cCreateKeyword_3; }
		
		//parameters+=ClassicallyNamedModelElement+
		public Assignment getParametersAssignment_4() { return cParametersAssignment_4; }
		
		//ClassicallyNamedModelElement
		public RuleCall getParametersClassicallyNamedModelElementParserRuleCall_4_0() { return cParametersClassicallyNamedModelElementParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//('with {' bootstrapConditon=SingleSidedCondition '}')?
		public Group getGroup_6() { return cGroup_6; }
		
		//'with {'
		public Keyword getWithKeyword_6_0() { return cWithKeyword_6_0; }
		
		//bootstrapConditon=SingleSidedCondition
		public Assignment getBootstrapConditonAssignment_6_1() { return cBootstrapConditonAssignment_6_1; }
		
		//SingleSidedCondition
		public RuleCall getBootstrapConditonSingleSidedConditionParserRuleCall_6_1_0() { return cBootstrapConditonSingleSidedConditionParserRuleCall_6_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6_2() { return cRightCurlyBracketKeyword_6_2; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class CodeBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.CodeBlock");
		private final Assignment cCodeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCodeXExpressionParserRuleCall_0 = (RuleCall)cCodeAssignment.eContents().get(0);
		
		///***************************/ /* END BOOTSTRAPPING */ /***************************/ /***************************/
		///* BEGIN REFACTOR */ /***************************/ // TODO MK: move fragment CodeBlock to MirBase (not MetaBase :-)
		//fragment CodeBlock:
		//	code=XExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//code=XExpression
		public Assignment getCodeAssignment() { return cCodeAssignment; }
		
		//XExpression
		public RuleCall getCodeXExpressionParserRuleCall_0() { return cCodeXExpressionParserRuleCall_0; }
	}
	public class DocumentableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.Documentable");
		private final Assignment cDocumentationAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDocumentationML_COMMENTTerminalRuleCall_0 = (RuleCall)cDocumentationAssignment.eContents().get(0);
		
		//// TODO MK: move documentable to MetaBase and use it in Reactions	
		//fragment Documentable:
		//	documentation=ML_COMMENT?;
		@Override public ParserRule getRule() { return rule; }
		
		//documentation=ML_COMMENT?
		public Assignment getDocumentationAssignment() { return cDocumentationAssignment; }
		
		//ML_COMMENT
		public RuleCall getDocumentationML_COMMENTTerminalRuleCall_0() { return cDocumentationML_COMMENTTerminalRuleCall_0; }
	}
	
	public class NumCompareOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.NumCompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOT_GREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOT_GREATERLessThanSignEqualsSignKeyword_0_0 = (Keyword)cNOT_GREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESSLessThanSignKeyword_1_0 = (Keyword)cLESSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_LESSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNOT_LESSGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cNOT_LESSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATERGreaterThanSignKeyword_3_0 = (Keyword)cGREATEREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum NumCompareOperator:
		//	NOT_GREATER='<=' |
		//	LESS="<" |
		//	NOT_LESS=">=" |
		//	GREATER=">";
		public EnumRule getRule() { return rule; }
		
		//NOT_GREATER='<=' | LESS="<" | NOT_LESS=">=" | GREATER=">"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NOT_GREATER='<='
		public EnumLiteralDeclaration getNOT_GREATEREnumLiteralDeclaration_0() { return cNOT_GREATEREnumLiteralDeclaration_0; }
		
		//'<='
		public Keyword getNOT_GREATERLessThanSignEqualsSignKeyword_0_0() { return cNOT_GREATERLessThanSignEqualsSignKeyword_0_0; }
		
		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_1() { return cLESSEnumLiteralDeclaration_1; }
		
		//"<"
		public Keyword getLESSLessThanSignKeyword_1_0() { return cLESSLessThanSignKeyword_1_0; }
		
		//NOT_LESS=">="
		public EnumLiteralDeclaration getNOT_LESSEnumLiteralDeclaration_2() { return cNOT_LESSEnumLiteralDeclaration_2; }
		
		//">="
		public Keyword getNOT_LESSGreaterThanSignEqualsSignKeyword_2_0() { return cNOT_LESSGreaterThanSignEqualsSignKeyword_2_0; }
		
		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_3() { return cGREATEREnumLiteralDeclaration_3; }
		
		//">"
		public Keyword getGREATERGreaterThanSignKeyword_3_0() { return cGREATERGreaterThanSignKeyword_3_0; }
	}
	public class MultiValueConditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "tools.vitruv.dsls.mappings.MappingsLanguage.MultiValueConditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINInKeyword_1_0 = (Keyword)cINEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiValueConditionOperator:
		//	EQUALS='equals' |
		//	IN='in';
		public EnumRule getRule() { return rule; }
		
		//EQUALS='equals' | IN='in'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS='equals'
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }
		
		//'equals'
		public Keyword getEQUALSEqualsKeyword_0_0() { return cEQUALSEqualsKeyword_0_0; }
		
		//IN='in'
		public EnumLiteralDeclaration getINEnumLiteralDeclaration_1() { return cINEnumLiteralDeclaration_1; }
		
		//'in'
		public Keyword getINInKeyword_1_0() { return cINInKeyword_1_0; }
	}
	
	private final MappingsFileElements pMappingsFile;
	private final MappingsSegmentElements pMappingsSegment;
	private final MappingElements pMapping;
	private final DependencyElements pDependency;
	private final SingleSidedConditionElements pSingleSidedCondition;
	private final EnforceableConditionElements pEnforceableCondition;
	private final FeatureConditionElements pFeatureCondition;
	private final FeatureReferenceElements pFeatureReference;
	private final DependentFeatureReferenceElements pDependentFeatureReference;
	private final SingleValueConditionElements pSingleValueCondition;
	private final ValueConditionElements pValueCondition;
	private final ValueExpressionElements pValueExpression;
	private final IndexConditionElements pIndexCondition;
	private final NumCompareConditionElements pNumCompareCondition;
	private final NumCompareOperatorElements eNumCompareOperator;
	private final MultiValueConditionElements pMultiValueCondition;
	private final MultiValueConditionOperatorElements eMultiValueConditionOperator;
	private final ElementConditionElements pElementCondition;
	private final ElementExpressionElements pElementExpression;
	private final NotEmptyConditionElements pNotEmptyCondition;
	private final ResourceConditionElements pResourceCondition;
	private final CheckAndEnforceConditionElements pCheckAndEnforceCondition;
	private final CheckExpressionElements pCheckExpression;
	private final EnforceExpressionElements pEnforceExpression;
	private final BidirectionalizableConditionElements pBidirectionalizableCondition;
	private final BidirectionalizableExpressionElements pBidirectionalizableExpression;
	private final UnidirectionalExpressionElements pUnidirectionalExpression;
	private final BootstrappingElements pBootstrapping;
	private final CodeBlockElements pCodeBlock;
	private final DocumentableElements pDocumentable;
	
	private final Grammar grammar;
	
	private final MirBaseGrammarAccess gaMirBase;
	
	private final XbaseGrammarAccess gaXbase;
	
	private final XtypeGrammarAccess gaXtype;

	@Inject
	public MappingsLanguageGrammarAccess(GrammarProvider grammarProvider,
			MirBaseGrammarAccess gaMirBase,
			XbaseGrammarAccess gaXbase,
			XtypeGrammarAccess gaXtype) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaMirBase = gaMirBase;
		this.gaXbase = gaXbase;
		this.gaXtype = gaXtype;
		this.pMappingsFile = new MappingsFileElements();
		this.pMappingsSegment = new MappingsSegmentElements();
		this.pMapping = new MappingElements();
		this.pDependency = new DependencyElements();
		this.pSingleSidedCondition = new SingleSidedConditionElements();
		this.pEnforceableCondition = new EnforceableConditionElements();
		this.pFeatureCondition = new FeatureConditionElements();
		this.pFeatureReference = new FeatureReferenceElements();
		this.pDependentFeatureReference = new DependentFeatureReferenceElements();
		this.pSingleValueCondition = new SingleValueConditionElements();
		this.pValueCondition = new ValueConditionElements();
		this.pValueExpression = new ValueExpressionElements();
		this.pIndexCondition = new IndexConditionElements();
		this.pNumCompareCondition = new NumCompareConditionElements();
		this.eNumCompareOperator = new NumCompareOperatorElements();
		this.pMultiValueCondition = new MultiValueConditionElements();
		this.eMultiValueConditionOperator = new MultiValueConditionOperatorElements();
		this.pElementCondition = new ElementConditionElements();
		this.pElementExpression = new ElementExpressionElements();
		this.pNotEmptyCondition = new NotEmptyConditionElements();
		this.pResourceCondition = new ResourceConditionElements();
		this.pCheckAndEnforceCondition = new CheckAndEnforceConditionElements();
		this.pCheckExpression = new CheckExpressionElements();
		this.pEnforceExpression = new EnforceExpressionElements();
		this.pBidirectionalizableCondition = new BidirectionalizableConditionElements();
		this.pBidirectionalizableExpression = new BidirectionalizableExpressionElements();
		this.pUnidirectionalExpression = new UnidirectionalExpressionElements();
		this.pBootstrapping = new BootstrappingElements();
		this.pCodeBlock = new CodeBlockElements();
		this.pDocumentable = new DocumentableElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("tools.vitruv.dsls.mappings.MappingsLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public MirBaseGrammarAccess getMirBaseGrammarAccess() {
		return gaMirBase;
	}
	
	public XbaseGrammarAccess getXbaseGrammarAccess() {
		return gaXbase;
	}
	
	public XtypeGrammarAccess getXtypeGrammarAccess() {
		return gaXtype;
	}

	
	//MappingsFile:
	//	namespaceImports=XImportSection?
	//	MirBaseFile
	//	mappingsSegments+=MappingsSegment+;
	public MappingsFileElements getMappingsFileAccess() {
		return pMappingsFile;
	}
	
	public ParserRule getMappingsFileRule() {
		return getMappingsFileAccess().getRule();
	}
	
	//MappingsSegment:
	//	Documentable
	//	'mappings:' name=ValidID
	//	'for' leftDomain=DomainReference
	//	'and' rightDomain=DomainReference (mappings+=Mapping | bootstrappings+=Bootstrapping)*;
	public MappingsSegmentElements getMappingsSegmentAccess() {
		return pMappingsSegment;
	}
	
	public ParserRule getMappingsSegmentRule() {
		return getMappingsSegmentAccess().getRule();
	}
	
	///******************/ /* BEGIN MAPPINGS */ /******************/ Mapping:
	//	'mapping' name=ValidID ('depends on ('
	//	dependencies+=Dependency
	//	')')?
	//	'{'
	//	'map (' leftParameters+=ClassicallyNamedModelElement+ ')' ('with {'
	//	leftConditions+=SingleSidedCondition+
	//	'}')?
	//	'and (' rightParameters+=ClassicallyNamedModelElement+ ')' ('with {'
	//	rightConditions+=SingleSidedCondition+
	//	'}')? ('such that {'
	//	bidirectionalizableConditions+=BidirectionalizableCondition+
	//	'}')? ('forward execute {'
	//	forwardExecutionExpression=UnidirectionalExpression
	//	'} backward execute {'
	//	backwardExecutionExpression=UnidirectionalExpression
	//	'}')?
	//	'}';
	public MappingElements getMappingAccess() {
		return pMapping;
	}
	
	public ParserRule getMappingRule() {
		return getMappingAccess().getRule();
	}
	
	//// DW: RequiredMapping
	//Dependency:
	//	mapping=[Mapping] shortName=ValidID;
	public DependencyElements getDependencyAccess() {
		return pDependency;
	}
	
	public ParserRule getDependencyRule() {
		return getDependencyAccess().getRule();
	}
	
	//SingleSidedCondition:
	//	EnforceableCondition | CheckAndEnforceCondition;
	public SingleSidedConditionElements getSingleSidedConditionAccess() {
		return pSingleSidedCondition;
	}
	
	public ParserRule getSingleSidedConditionRule() {
		return getSingleSidedConditionAccess().getRule();
	}
	
	///* BEGIN ENFORCEABLE CONDITIONS */ EnforceableCondition:
	//	FeatureCondition | ResourceCondition;
	public EnforceableConditionElements getEnforceableConditionAccess() {
		return pEnforceableCondition;
	}
	
	public ParserRule getEnforceableConditionRule() {
		return getEnforceableConditionAccess().getRule();
	}
	
	//FeatureCondition:
	//	(SingleValueCondition | MultiValueCondition | ElementCondition | NotEmptyCondition) feature=MetaclassFeatureReference;
	public FeatureConditionElements getFeatureConditionAccess() {
		return pFeatureCondition;
	}
	
	public ParserRule getFeatureConditionRule() {
		return getFeatureConditionAccess().getRule();
	}
	
	//FeatureReference:
	//	DependentFeatureReference | {MetaclassFeatureReference};
	public FeatureReferenceElements getFeatureReferenceAccess() {
		return pFeatureReference;
	}
	
	public ParserRule getFeatureReferenceRule() {
		return getFeatureReferenceAccess().getRule();
	}
	
	//// DW: FeatureOfContextVariable
	//DependentFeatureReference:
	//	dependeeShortName=[Dependency|ValidID]
	//	':'
	//	dependeeFeature=MetaclassFeatureReference;
	public DependentFeatureReferenceElements getDependentFeatureReferenceAccess() {
		return pDependentFeatureReference;
	}
	
	public ParserRule getDependentFeatureReferenceRule() {
		return getDependentFeatureReferenceAccess().getRule();
	}
	
	//SingleValueCondition:
	//	IndexCondition | NumCompareCondition;
	public SingleValueConditionElements getSingleValueConditionAccess() {
		return pSingleValueCondition;
	}
	
	public ParserRule getSingleValueConditionRule() {
		return getSingleValueConditionAccess().getRule();
	}
	
	//ValueCondition:
	//	valueExpression=ValueExpression;
	public ValueConditionElements getValueConditionAccess() {
		return pValueCondition;
	}
	
	public ParserRule getValueConditionRule() {
		return getValueConditionAccess().getRule();
	}
	
	//ValueExpression:
	//	{CodeBlock};
	public ValueExpressionElements getValueExpressionAccess() {
		return pValueExpression;
	}
	
	public ParserRule getValueExpressionRule() {
		return getValueExpressionAccess().getRule();
	}
	
	//IndexCondition:
	//	negated?='not'
	//	'at index'
	//	indexValueExpression=ValueExpression
	//	'in';
	public IndexConditionElements getIndexConditionAccess() {
		return pIndexCondition;
	}
	
	public ParserRule getIndexConditionRule() {
		return getIndexConditionAccess().getRule();
	}
	
	//NumCompareCondition:
	//	operator=NumCompareOperator;
	public NumCompareConditionElements getNumCompareConditionAccess() {
		return pNumCompareCondition;
	}
	
	public ParserRule getNumCompareConditionRule() {
		return getNumCompareConditionAccess().getRule();
	}
	
	//enum NumCompareOperator:
	//	NOT_GREATER='<=' |
	//	LESS="<" |
	//	NOT_LESS=">=" |
	//	GREATER=">";
	public NumCompareOperatorElements getNumCompareOperatorAccess() {
		return eNumCompareOperator;
	}
	
	public EnumRule getNumCompareOperatorRule() {
		return getNumCompareOperatorAccess().getRule();
	}
	
	///*
	//NumCompareOperator returns SingleValueConditionOperator:
	//	NotGreaterOperator |
	//	LessOperator |
	//	NotLessOperator |
	//	GreaterOperator
	//;
	//
	//NotGreaterOperator returns NumCompareOperator: '<=';
	//
	//LessOperator returns NumCompareOperator: '<';
	//
	//NotLessOperator returns NumCompareOperator: '>=';
	//
	//GreaterOperator returns NumCompareOperator: '>';
	//*/ MultiValueCondition:
	//	negated?='not'
	//	operator=MultiValueConditionOperator;
	public MultiValueConditionElements getMultiValueConditionAccess() {
		return pMultiValueCondition;
	}
	
	public ParserRule getMultiValueConditionRule() {
		return getMultiValueConditionAccess().getRule();
	}
	
	//enum MultiValueConditionOperator:
	//	EQUALS='equals' |
	//	IN='in';
	public MultiValueConditionOperatorElements getMultiValueConditionOperatorAccess() {
		return eMultiValueConditionOperator;
	}
	
	public EnumRule getMultiValueConditionOperatorRule() {
		return getMultiValueConditionOperatorAccess().getRule();
	}
	
	//ElementCondition:
	//	elementExpression=ElementExpression
	//	'default contained in';
	public ElementConditionElements getElementConditionAccess() {
		return pElementCondition;
	}
	
	public ParserRule getElementConditionRule() {
		return getElementConditionAccess().getRule();
	}
	
	//ElementExpression:
	//	{CodeBlock};
	public ElementExpressionElements getElementExpressionAccess() {
		return pElementExpression;
	}
	
	public ParserRule getElementExpressionRule() {
		return getElementExpressionAccess().getRule();
	}
	
	//NotEmptyCondition:
	//	negated?='not'
	//	'empty';
	public NotEmptyConditionElements getNotEmptyConditionAccess() {
		return pNotEmptyCondition;
	}
	
	public ParserRule getNotEmptyConditionRule() {
		return getNotEmptyConditionAccess().getRule();
	}
	
	//ResourceCondition: //  returns EnforceableCondition:
	//	'default path for' elementExpression=ElementExpression '=' ('path of' pathExpression=ElementExpression "+")?
	//	path=STRING;
	public ResourceConditionElements getResourceConditionAccess() {
		return pResourceCondition;
	}
	
	public ParserRule getResourceConditionRule() {
		return getResourceConditionAccess().getRule();
	}
	
	///* END ENFORCEABLE CONDITIONS */ /* BEGIN CHECK AND ENFORCE CONDITION*/ CheckAndEnforceCondition: //  returns SingleSidedCondition:
	//	'check {' checkExpression=CheckExpression '}
	//	enforce {' enforceExpression=CheckExpression '}';
	public CheckAndEnforceConditionElements getCheckAndEnforceConditionAccess() {
		return pCheckAndEnforceCondition;
	}
	
	public ParserRule getCheckAndEnforceConditionRule() {
		return getCheckAndEnforceConditionAccess().getRule();
	}
	
	//CheckExpression:
	//	{CodeBlock};
	public CheckExpressionElements getCheckExpressionAccess() {
		return pCheckExpression;
	}
	
	public ParserRule getCheckExpressionRule() {
		return getCheckExpressionAccess().getRule();
	}
	
	//EnforceExpression:
	//	{CodeBlock};
	public EnforceExpressionElements getEnforceExpressionAccess() {
		return pEnforceExpression;
	}
	
	public ParserRule getEnforceExpressionRule() {
		return getEnforceExpressionAccess().getRule();
	}
	
	///* END CHECK AND ENFORCE CONDITION */ /* BEGIN BIDIRECTIONALIZABLE CONDITION */ BidirectionalizableCondition:
	//	featureToBeAssigned=MetaclassFeatureReference
	//	'='
	//	bidirectionalizableExpression=BidirectionalizableExpression ('update' featureToBeUpdated=MetaclassFeatureReference)?;
	public BidirectionalizableConditionElements getBidirectionalizableConditionAccess() {
		return pBidirectionalizableCondition;
	}
	
	public ParserRule getBidirectionalizableConditionRule() {
		return getBidirectionalizableConditionAccess().getRule();
	}
	
	//BidirectionalizableExpression:
	//	{CodeBlock};
	public BidirectionalizableExpressionElements getBidirectionalizableExpressionAccess() {
		return pBidirectionalizableExpression;
	}
	
	public ParserRule getBidirectionalizableExpressionRule() {
		return getBidirectionalizableExpressionAccess().getRule();
	}
	
	///* END BIDIRECTIONALIZABLE CONDITION */ UnidirectionalExpression:
	//	{CodeBlock};
	public UnidirectionalExpressionElements getUnidirectionalExpressionAccess() {
		return pUnidirectionalExpression;
	}
	
	public ParserRule getUnidirectionalExpressionRule() {
		return getUnidirectionalExpressionAccess().getRule();
	}
	
	///******************/ /* END MAPPINGS */ /******************/ /***************************/ /* BEGIN BOOTSTRAPPING */
	///***************************/ Bootstrapping:
	//	'bootstrapping' name=ValidID
	//	'{'
	//	'create (' parameters+=ClassicallyNamedModelElement+ ')' ('with {'
	//	bootstrapConditon=SingleSidedCondition
	//	'}')?
	//	'}';
	public BootstrappingElements getBootstrappingAccess() {
		return pBootstrapping;
	}
	
	public ParserRule getBootstrappingRule() {
		return getBootstrappingAccess().getRule();
	}
	
	///***************************/ /* END BOOTSTRAPPING */ /***************************/ /***************************/
	///* BEGIN REFACTOR */ /***************************/ // TODO MK: move fragment CodeBlock to MirBase (not MetaBase :-)
	//fragment CodeBlock:
	//	code=XExpression;
	public CodeBlockElements getCodeBlockAccess() {
		return pCodeBlock;
	}
	
	public ParserRule getCodeBlockRule() {
		return getCodeBlockAccess().getRule();
	}
	
	//// TODO MK: move documentable to MetaBase and use it in Reactions	
	//fragment Documentable:
	//	documentation=ML_COMMENT?;
	public DocumentableElements getDocumentableAccess() {
		return pDocumentable;
	}
	
	public ParserRule getDocumentableRule() {
		return getDocumentableAccess().getRule();
	}
	
	//DummyEntryRule:
	//	MirBaseFile;
	public MirBaseGrammarAccess.DummyEntryRuleElements getDummyEntryRuleAccess() {
		return gaMirBase.getDummyEntryRuleAccess();
	}
	
	public ParserRule getDummyEntryRuleRule() {
		return getDummyEntryRuleAccess().getRule();
	}
	
	//fragment MirBaseFile:
	//	metamodelImports+=MetamodelImport*;
	public MirBaseGrammarAccess.MirBaseFileElements getMirBaseFileAccess() {
		return gaMirBase.getMirBaseFileAccess();
	}
	
	public ParserRule getMirBaseFileRule() {
		return getMirBaseFileAccess().getRule();
	}
	
	//MetamodelImport:
	//	'import' package=[ecore::EPackage|STRING] 'as' name=ValidID useQualifiedNames?='using qualified names'?;
	public MirBaseGrammarAccess.MetamodelImportElements getMetamodelImportAccess() {
		return gaMirBase.getMetamodelImportAccess();
	}
	
	public ParserRule getMetamodelImportRule() {
		return getMetamodelImportAccess().getRule();
	}
	
	//NamedJavaElement:
	//	type=JvmTypeReference 'as' name=ValidID;
	public MirBaseGrammarAccess.NamedJavaElementElements getNamedJavaElementAccess() {
		return gaMirBase.getNamedJavaElementAccess();
	}
	
	public ParserRule getNamedJavaElementRule() {
		return getNamedJavaElementAccess().getRule();
	}
	
	//fragment MetaclassReference:
	//	(metamodel=[MetamodelImport] '::')? metaclass=[ecore::EClass|QualifiedName];
	public MirBaseGrammarAccess.MetaclassReferenceElements getMetaclassReferenceAccess() {
		return gaMirBase.getMetaclassReferenceAccess();
	}
	
	public ParserRule getMetaclassReferenceRule() {
		return getMetaclassReferenceAccess().getRule();
	}
	
	//UnnamedMetaclassReference MetaclassReference:
	//	MetaclassReference;
	public MirBaseGrammarAccess.UnnamedMetaclassReferenceElements getUnnamedMetaclassReferenceAccess() {
		return gaMirBase.getUnnamedMetaclassReferenceAccess();
	}
	
	public ParserRule getUnnamedMetaclassReferenceRule() {
		return getUnnamedMetaclassReferenceAccess().getRule();
	}
	
	//NamedMetaclassReference:
	//	MetaclassReference ('as' name=ValidID)?;
	public MirBaseGrammarAccess.NamedMetaclassReferenceElements getNamedMetaclassReferenceAccess() {
		return gaMirBase.getNamedMetaclassReferenceAccess();
	}
	
	public ParserRule getNamedMetaclassReferenceRule() {
		return getNamedMetaclassReferenceAccess().getRule();
	}
	
	//ClassicallyNamedModelElement NamedMetaclassReference:
	//	MetaclassReference name=ValidID;
	public MirBaseGrammarAccess.ClassicallyNamedModelElementElements getClassicallyNamedModelElementAccess() {
		return gaMirBase.getClassicallyNamedModelElementAccess();
	}
	
	public ParserRule getClassicallyNamedModelElementRule() {
		return getClassicallyNamedModelElementAccess().getRule();
	}
	
	////fragment ModelElement:
	////	element=[ecore::EClass|QualifiedName]
	////;
	////
	////UnnamedModelElement:
	////	ModelElement;
	////		
	////NamedModelElement:
	////	ModelElement ('as' name=ValidID)?
	////;
	//MetaclassFeatureReference:
	//	MetaclassReference '[' feature=[ecore::EStructuralFeature|ValidID] ']';
	public MirBaseGrammarAccess.MetaclassFeatureReferenceElements getMetaclassFeatureReferenceAccess() {
		return gaMirBase.getMetaclassFeatureReferenceAccess();
	}
	
	public ParserRule getMetaclassFeatureReferenceRule() {
		return getMetaclassFeatureReferenceAccess().getRule();
	}
	
	//MetaclassEAttributeReference:
	//	MetaclassReference '[' feature=[ecore::EAttribute|ValidID] ']';
	public MirBaseGrammarAccess.MetaclassEAttributeReferenceElements getMetaclassEAttributeReferenceAccess() {
		return gaMirBase.getMetaclassEAttributeReferenceAccess();
	}
	
	public ParserRule getMetaclassEAttributeReferenceRule() {
		return getMetaclassEAttributeReferenceAccess().getRule();
	}
	
	//MetaclassEReferenceReference:
	//	MetaclassReference '[' feature=[ecore::EReference|ValidID] ']';
	public MirBaseGrammarAccess.MetaclassEReferenceReferenceElements getMetaclassEReferenceReferenceAccess() {
		return gaMirBase.getMetaclassEReferenceReferenceAccess();
	}
	
	public ParserRule getMetaclassEReferenceReferenceRule() {
		return getMetaclassEReferenceReferenceAccess().getRule();
	}
	
	//MetamodelReference:
	//	model=[MetamodelImport];
	public MirBaseGrammarAccess.MetamodelReferenceElements getMetamodelReferenceAccess() {
		return gaMirBase.getMetamodelReferenceAccess();
	}
	
	public ParserRule getMetamodelReferenceRule() {
		return getMetamodelReferenceAccess().getRule();
	}
	
	//DomainReference:
	//	domain=ID;
	public MirBaseGrammarAccess.DomainReferenceElements getDomainReferenceAccess() {
		return gaMirBase.getDomainReferenceAccess();
	}
	
	public ParserRule getDomainReferenceRule() {
		return getDomainReferenceAccess().getRule();
	}
	
	//XExpression:
	//	XAssignment;
	public XbaseGrammarAccess.XExpressionElements getXExpressionAccess() {
		return gaXbase.getXExpressionAccess();
	}
	
	public ParserRule getXExpressionRule() {
		return getXExpressionAccess().getRule();
	}
	
	//XAssignment XExpression:
	//	{XAssignment} feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign value=XAssignment | XOrExpression
	//	(=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpMultiAssign])
	//	rightOperand=XAssignment)?;
	public XbaseGrammarAccess.XAssignmentElements getXAssignmentAccess() {
		return gaXbase.getXAssignmentAccess();
	}
	
	public ParserRule getXAssignmentRule() {
		return getXAssignmentAccess().getRule();
	}
	
	//OpSingleAssign:
	//	'=';
	public XbaseGrammarAccess.OpSingleAssignElements getOpSingleAssignAccess() {
		return gaXbase.getOpSingleAssignAccess();
	}
	
	public ParserRule getOpSingleAssignRule() {
		return getOpSingleAssignAccess().getRule();
	}
	
	//OpMultiAssign:
	//	'+=' | '-=' | '*=' | '/=' | '%=' |
	//	'<' '<' '=' |
	//	'>' '>'? '>=';
	public XbaseGrammarAccess.OpMultiAssignElements getOpMultiAssignAccess() {
		return gaXbase.getOpMultiAssignAccess();
	}
	
	public ParserRule getOpMultiAssignRule() {
		return getOpMultiAssignAccess().getRule();
	}
	
	//XOrExpression XExpression:
	//	XAndExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpOr])
	//	rightOperand=XAndExpression)*;
	public XbaseGrammarAccess.XOrExpressionElements getXOrExpressionAccess() {
		return gaXbase.getXOrExpressionAccess();
	}
	
	public ParserRule getXOrExpressionRule() {
		return getXOrExpressionAccess().getRule();
	}
	
	//OpOr:
	//	'||';
	public XbaseGrammarAccess.OpOrElements getOpOrAccess() {
		return gaXbase.getOpOrAccess();
	}
	
	public ParserRule getOpOrRule() {
		return getOpOrAccess().getRule();
	}
	
	//XAndExpression XExpression:
	//	XEqualityExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpAnd])
	//	rightOperand=XEqualityExpression)*;
	public XbaseGrammarAccess.XAndExpressionElements getXAndExpressionAccess() {
		return gaXbase.getXAndExpressionAccess();
	}
	
	public ParserRule getXAndExpressionRule() {
		return getXAndExpressionAccess().getRule();
	}
	
	//OpAnd:
	//	'&&';
	public XbaseGrammarAccess.OpAndElements getOpAndAccess() {
		return gaXbase.getOpAndAccess();
	}
	
	public ParserRule getOpAndRule() {
		return getOpAndAccess().getRule();
	}
	
	//XEqualityExpression XExpression:
	//	XRelationalExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpEquality])
	//	rightOperand=XRelationalExpression)*;
	public XbaseGrammarAccess.XEqualityExpressionElements getXEqualityExpressionAccess() {
		return gaXbase.getXEqualityExpressionAccess();
	}
	
	public ParserRule getXEqualityExpressionRule() {
		return getXEqualityExpressionAccess().getRule();
	}
	
	//OpEquality:
	//	'==' | '!=' | '===' | '!==';
	public XbaseGrammarAccess.OpEqualityElements getOpEqualityAccess() {
		return gaXbase.getOpEqualityAccess();
	}
	
	public ParserRule getOpEqualityRule() {
		return getOpEqualityAccess().getRule();
	}
	
	//XRelationalExpression XExpression:
	//	XOtherOperatorExpression (=> ({XInstanceOfExpression.expression=current} 'instanceof') type=JvmTypeReference |
	//	=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpCompare])
	//	rightOperand=XOtherOperatorExpression)*;
	public XbaseGrammarAccess.XRelationalExpressionElements getXRelationalExpressionAccess() {
		return gaXbase.getXRelationalExpressionAccess();
	}
	
	public ParserRule getXRelationalExpressionRule() {
		return getXRelationalExpressionAccess().getRule();
	}
	
	//OpCompare:
	//	'>=' | '<' '=' | '>' | '<';
	public XbaseGrammarAccess.OpCompareElements getOpCompareAccess() {
		return gaXbase.getOpCompareAccess();
	}
	
	public ParserRule getOpCompareRule() {
		return getOpCompareAccess().getRule();
	}
	
	//XOtherOperatorExpression XExpression:
	//	XAdditiveExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpOther])
	//	rightOperand=XAdditiveExpression)*;
	public XbaseGrammarAccess.XOtherOperatorExpressionElements getXOtherOperatorExpressionAccess() {
		return gaXbase.getXOtherOperatorExpressionAccess();
	}
	
	public ParserRule getXOtherOperatorExpressionRule() {
		return getXOtherOperatorExpressionAccess().getRule();
	}
	
	//OpOther:
	//	'->'
	//	| '..<'
	//	| '>' '..'
	//	| '..'
	//	| '=>'
	//	| '>' (=> ('>' '>') | '>') | '<' (=> ('<' '<') | '<' | '=>') | '<>'
	//	| '?:';
	public XbaseGrammarAccess.OpOtherElements getOpOtherAccess() {
		return gaXbase.getOpOtherAccess();
	}
	
	public ParserRule getOpOtherRule() {
		return getOpOtherAccess().getRule();
	}
	
	//XAdditiveExpression XExpression:
	//	XMultiplicativeExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpAdd])
	//	rightOperand=XMultiplicativeExpression)*;
	public XbaseGrammarAccess.XAdditiveExpressionElements getXAdditiveExpressionAccess() {
		return gaXbase.getXAdditiveExpressionAccess();
	}
	
	public ParserRule getXAdditiveExpressionRule() {
		return getXAdditiveExpressionAccess().getRule();
	}
	
	//OpAdd:
	//	'+' | '-';
	public XbaseGrammarAccess.OpAddElements getOpAddAccess() {
		return gaXbase.getOpAddAccess();
	}
	
	public ParserRule getOpAddRule() {
		return getOpAddAccess().getRule();
	}
	
	//XMultiplicativeExpression XExpression:
	//	XUnaryOperation (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpMulti])
	//	rightOperand=XUnaryOperation)*;
	public XbaseGrammarAccess.XMultiplicativeExpressionElements getXMultiplicativeExpressionAccess() {
		return gaXbase.getXMultiplicativeExpressionAccess();
	}
	
	public ParserRule getXMultiplicativeExpressionRule() {
		return getXMultiplicativeExpressionAccess().getRule();
	}
	
	//OpMulti:
	//	'*' | '**' | '/' | '%';
	public XbaseGrammarAccess.OpMultiElements getOpMultiAccess() {
		return gaXbase.getOpMultiAccess();
	}
	
	public ParserRule getOpMultiRule() {
		return getOpMultiAccess().getRule();
	}
	
	//XUnaryOperation XExpression:
	//	{XUnaryOperation} feature=[types::JvmIdentifiableElement|OpUnary] operand=XUnaryOperation
	//	| XCastedExpression;
	public XbaseGrammarAccess.XUnaryOperationElements getXUnaryOperationAccess() {
		return gaXbase.getXUnaryOperationAccess();
	}
	
	public ParserRule getXUnaryOperationRule() {
		return getXUnaryOperationAccess().getRule();
	}
	
	//OpUnary:
	//	"!" | "-" | "+";
	public XbaseGrammarAccess.OpUnaryElements getOpUnaryAccess() {
		return gaXbase.getOpUnaryAccess();
	}
	
	public ParserRule getOpUnaryRule() {
		return getOpUnaryAccess().getRule();
	}
	
	//XCastedExpression XExpression:
	//	XPostfixOperation (=> ({XCastedExpression.target=current} 'as') type=JvmTypeReference)*;
	public XbaseGrammarAccess.XCastedExpressionElements getXCastedExpressionAccess() {
		return gaXbase.getXCastedExpressionAccess();
	}
	
	public ParserRule getXCastedExpressionRule() {
		return getXCastedExpressionAccess().getRule();
	}
	
	//XPostfixOperation XExpression:
	//	XMemberFeatureCall => ({XPostfixOperation.operand=current} feature=[types::JvmIdentifiableElement|OpPostfix])?;
	public XbaseGrammarAccess.XPostfixOperationElements getXPostfixOperationAccess() {
		return gaXbase.getXPostfixOperationAccess();
	}
	
	public ParserRule getXPostfixOperationRule() {
		return getXPostfixOperationAccess().getRule();
	}
	
	//OpPostfix:
	//	"++" | "--";
	public XbaseGrammarAccess.OpPostfixElements getOpPostfixAccess() {
		return gaXbase.getOpPostfixAccess();
	}
	
	public ParserRule getOpPostfixRule() {
		return getOpPostfixAccess().getRule();
	}
	
	//XMemberFeatureCall XExpression:
	//	XPrimaryExpression (=> ({XAssignment.assignable=current} ('.' | explicitStatic?="::")
	//	feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign) value=XAssignment
	//	| => ({XMemberFeatureCall.memberCallTarget=current} ("." | nullSafe?="?." | explicitStatic?="::")) ('<'
	//	typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	//	feature=[types::JvmIdentifiableElement|IdOrSuper] (=> explicitOperationCall?='(' (memberCallArguments+=XShortClosure
	//	| memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*)?
	//	')')?
	//	memberCallArguments+=XClosure?)*;
	public XbaseGrammarAccess.XMemberFeatureCallElements getXMemberFeatureCallAccess() {
		return gaXbase.getXMemberFeatureCallAccess();
	}
	
	public ParserRule getXMemberFeatureCallRule() {
		return getXMemberFeatureCallAccess().getRule();
	}
	
	//XPrimaryExpression XExpression:
	//	XConstructorCall | XBlockExpression | XSwitchExpression | XSynchronizedExpression | XFeatureCall | XLiteral |
	//	XIfExpression | XForLoopExpression | XBasicForLoopExpression | XWhileExpression | XDoWhileExpression |
	//	XThrowExpression | XReturnExpression | XTryCatchFinallyExpression | XParenthesizedExpression;
	public XbaseGrammarAccess.XPrimaryExpressionElements getXPrimaryExpressionAccess() {
		return gaXbase.getXPrimaryExpressionAccess();
	}
	
	public ParserRule getXPrimaryExpressionRule() {
		return getXPrimaryExpressionAccess().getRule();
	}
	
	//XLiteral XExpression:
	//	XCollectionLiteral | XClosure | XBooleanLiteral | XNumberLiteral | XNullLiteral | XStringLiteral | XTypeLiteral;
	public XbaseGrammarAccess.XLiteralElements getXLiteralAccess() {
		return gaXbase.getXLiteralAccess();
	}
	
	public ParserRule getXLiteralRule() {
		return getXLiteralAccess().getRule();
	}
	
	//XCollectionLiteral:
	//	XSetLiteral | XListLiteral;
	public XbaseGrammarAccess.XCollectionLiteralElements getXCollectionLiteralAccess() {
		return gaXbase.getXCollectionLiteralAccess();
	}
	
	public ParserRule getXCollectionLiteralRule() {
		return getXCollectionLiteralAccess().getRule();
	}
	
	//XSetLiteral:
	//	{XSetLiteral} '#' '{' (elements+=XExpression (',' elements+=XExpression)*)? '}';
	public XbaseGrammarAccess.XSetLiteralElements getXSetLiteralAccess() {
		return gaXbase.getXSetLiteralAccess();
	}
	
	public ParserRule getXSetLiteralRule() {
		return getXSetLiteralAccess().getRule();
	}
	
	//XListLiteral:
	//	{XListLiteral} '#' '[' (elements+=XExpression (',' elements+=XExpression)*)? ']';
	public XbaseGrammarAccess.XListLiteralElements getXListLiteralAccess() {
		return gaXbase.getXListLiteralAccess();
	}
	
	public ParserRule getXListLiteralRule() {
		return getXListLiteralAccess().getRule();
	}
	
	//XClosure XExpression:
	//	=> ({XClosure}
	//	'[')
	//	=> ((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)?
	//	explicitSyntax?='|')?
	//	expression=XExpressionInClosure
	//	']';
	public XbaseGrammarAccess.XClosureElements getXClosureAccess() {
		return gaXbase.getXClosureAccess();
	}
	
	public ParserRule getXClosureRule() {
		return getXClosureAccess().getRule();
	}
	
	//XExpressionInClosure XExpression:
	//	{XBlockExpression} (expressions+=XExpressionOrVarDeclaration ';'?)*;
	public XbaseGrammarAccess.XExpressionInClosureElements getXExpressionInClosureAccess() {
		return gaXbase.getXExpressionInClosureAccess();
	}
	
	public ParserRule getXExpressionInClosureRule() {
		return getXExpressionInClosureAccess().getRule();
	}
	
	//XShortClosure XExpression:
	//	=> ({XClosure} (declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)?
	//	explicitSyntax?='|') expression=XExpression;
	public XbaseGrammarAccess.XShortClosureElements getXShortClosureAccess() {
		return gaXbase.getXShortClosureAccess();
	}
	
	public ParserRule getXShortClosureRule() {
		return getXShortClosureAccess().getRule();
	}
	
	//XParenthesizedExpression XExpression:
	//	'(' XExpression ')';
	public XbaseGrammarAccess.XParenthesizedExpressionElements getXParenthesizedExpressionAccess() {
		return gaXbase.getXParenthesizedExpressionAccess();
	}
	
	public ParserRule getXParenthesizedExpressionRule() {
		return getXParenthesizedExpressionAccess().getRule();
	}
	
	//XIfExpression XExpression:
	//	{XIfExpression}
	//	'if' '(' if=XExpression ')'
	//	then=XExpression (=> 'else' else=XExpression)?;
	public XbaseGrammarAccess.XIfExpressionElements getXIfExpressionAccess() {
		return gaXbase.getXIfExpressionAccess();
	}
	
	public ParserRule getXIfExpressionRule() {
		return getXIfExpressionAccess().getRule();
	}
	
	//XSwitchExpression XExpression:
	//	{XSwitchExpression}
	//	'switch' (=> ('(' declaredParam=JvmFormalParameter ':') switch=XExpression ')'
	//	| => (declaredParam=JvmFormalParameter ':')? switch=XExpression) '{'
	//	cases+=XCasePart* ('default' ':' default=XExpression)?
	//	'}';
	public XbaseGrammarAccess.XSwitchExpressionElements getXSwitchExpressionAccess() {
		return gaXbase.getXSwitchExpressionAccess();
	}
	
	public ParserRule getXSwitchExpressionRule() {
		return getXSwitchExpressionAccess().getRule();
	}
	
	//XCasePart:
	//	{XCasePart} typeGuard=JvmTypeReference? ('case' case=XExpression)? (':' then=XExpression | fallThrough?=',');
	public XbaseGrammarAccess.XCasePartElements getXCasePartAccess() {
		return gaXbase.getXCasePartAccess();
	}
	
	public ParserRule getXCasePartRule() {
		return getXCasePartAccess().getRule();
	}
	
	//XForLoopExpression XExpression:
	//	=> ({XForLoopExpression}
	//	'for' '(' declaredParam=JvmFormalParameter ':') forExpression=XExpression ')'
	//	eachExpression=XExpression;
	public XbaseGrammarAccess.XForLoopExpressionElements getXForLoopExpressionAccess() {
		return gaXbase.getXForLoopExpressionAccess();
	}
	
	public ParserRule getXForLoopExpressionRule() {
		return getXForLoopExpressionAccess().getRule();
	}
	
	//XBasicForLoopExpression XExpression:
	//	{XBasicForLoopExpression}
	//	'for' '(' (initExpressions+=XExpressionOrVarDeclaration (',' initExpressions+=XExpressionOrVarDeclaration)*)? ';'
	//	expression=XExpression? ';' (updateExpressions+=XExpression (',' updateExpressions+=XExpression)*)? ')'
	//	eachExpression=XExpression;
	public XbaseGrammarAccess.XBasicForLoopExpressionElements getXBasicForLoopExpressionAccess() {
		return gaXbase.getXBasicForLoopExpressionAccess();
	}
	
	public ParserRule getXBasicForLoopExpressionRule() {
		return getXBasicForLoopExpressionAccess().getRule();
	}
	
	//XWhileExpression XExpression:
	//	{XWhileExpression}
	//	'while' '(' predicate=XExpression ')'
	//	body=XExpression;
	public XbaseGrammarAccess.XWhileExpressionElements getXWhileExpressionAccess() {
		return gaXbase.getXWhileExpressionAccess();
	}
	
	public ParserRule getXWhileExpressionRule() {
		return getXWhileExpressionAccess().getRule();
	}
	
	//XDoWhileExpression XExpression:
	//	{XDoWhileExpression}
	//	'do'
	//	body=XExpression
	//	'while' '(' predicate=XExpression ')';
	public XbaseGrammarAccess.XDoWhileExpressionElements getXDoWhileExpressionAccess() {
		return gaXbase.getXDoWhileExpressionAccess();
	}
	
	public ParserRule getXDoWhileExpressionRule() {
		return getXDoWhileExpressionAccess().getRule();
	}
	
	//XBlockExpression XExpression:
	//	{XBlockExpression}
	//	'{' (expressions+=XExpressionOrVarDeclaration ';'?)*
	//	'}';
	public XbaseGrammarAccess.XBlockExpressionElements getXBlockExpressionAccess() {
		return gaXbase.getXBlockExpressionAccess();
	}
	
	public ParserRule getXBlockExpressionRule() {
		return getXBlockExpressionAccess().getRule();
	}
	
	//XExpressionOrVarDeclaration XExpression:
	//	XVariableDeclaration | XExpression;
	public XbaseGrammarAccess.XExpressionOrVarDeclarationElements getXExpressionOrVarDeclarationAccess() {
		return gaXbase.getXExpressionOrVarDeclarationAccess();
	}
	
	public ParserRule getXExpressionOrVarDeclarationRule() {
		return getXExpressionOrVarDeclarationAccess().getRule();
	}
	
	//XVariableDeclaration XExpression:
	//	{XVariableDeclaration} (writeable?='var' | 'val') (=> (type=JvmTypeReference name=ValidID) | name=ValidID) ('='
	//	right=XExpression)?;
	public XbaseGrammarAccess.XVariableDeclarationElements getXVariableDeclarationAccess() {
		return gaXbase.getXVariableDeclarationAccess();
	}
	
	public ParserRule getXVariableDeclarationRule() {
		return getXVariableDeclarationAccess().getRule();
	}
	
	//JvmFormalParameter types::JvmFormalParameter:
	//	parameterType=JvmTypeReference? name=ValidID;
	public XbaseGrammarAccess.JvmFormalParameterElements getJvmFormalParameterAccess() {
		return gaXbase.getJvmFormalParameterAccess();
	}
	
	public ParserRule getJvmFormalParameterRule() {
		return getJvmFormalParameterAccess().getRule();
	}
	
	//FullJvmFormalParameter types::JvmFormalParameter:
	//	parameterType=JvmTypeReference name=ValidID;
	public XbaseGrammarAccess.FullJvmFormalParameterElements getFullJvmFormalParameterAccess() {
		return gaXbase.getFullJvmFormalParameterAccess();
	}
	
	public ParserRule getFullJvmFormalParameterRule() {
		return getFullJvmFormalParameterAccess().getRule();
	}
	
	//XFeatureCall XExpression:
	//	{XFeatureCall} ('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	//	feature=[types::JvmIdentifiableElement|IdOrSuper] (=> explicitOperationCall?='(' (featureCallArguments+=XShortClosure
	//	| featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*)?
	//	')')?
	//	featureCallArguments+=XClosure?;
	public XbaseGrammarAccess.XFeatureCallElements getXFeatureCallAccess() {
		return gaXbase.getXFeatureCallAccess();
	}
	
	public ParserRule getXFeatureCallRule() {
		return getXFeatureCallAccess().getRule();
	}
	
	//FeatureCallID:
	//	ValidID | 'extends' | 'static' | 'import' | 'extension';
	public XbaseGrammarAccess.FeatureCallIDElements getFeatureCallIDAccess() {
		return gaXbase.getFeatureCallIDAccess();
	}
	
	public ParserRule getFeatureCallIDRule() {
		return getFeatureCallIDAccess().getRule();
	}
	
	//IdOrSuper:
	//	FeatureCallID | 'super';
	public XbaseGrammarAccess.IdOrSuperElements getIdOrSuperAccess() {
		return gaXbase.getIdOrSuperAccess();
	}
	
	public ParserRule getIdOrSuperRule() {
		return getIdOrSuperAccess().getRule();
	}
	
	//XConstructorCall XExpression:
	//	{XConstructorCall}
	//	'new' constructor=[types::JvmConstructor|QualifiedName] (=> '<' typeArguments+=JvmArgumentTypeReference (','
	//	typeArguments+=JvmArgumentTypeReference)* '>')? (=> explicitConstructorCall?='(' (arguments+=XShortClosure
	//	| arguments+=XExpression (',' arguments+=XExpression)*)?
	//	')')?
	//	arguments+=XClosure?;
	public XbaseGrammarAccess.XConstructorCallElements getXConstructorCallAccess() {
		return gaXbase.getXConstructorCallAccess();
	}
	
	public ParserRule getXConstructorCallRule() {
		return getXConstructorCallAccess().getRule();
	}
	
	//XBooleanLiteral XExpression:
	//	{XBooleanLiteral} ('false' | isTrue?='true');
	public XbaseGrammarAccess.XBooleanLiteralElements getXBooleanLiteralAccess() {
		return gaXbase.getXBooleanLiteralAccess();
	}
	
	public ParserRule getXBooleanLiteralRule() {
		return getXBooleanLiteralAccess().getRule();
	}
	
	//XNullLiteral XExpression:
	//	{XNullLiteral} 'null';
	public XbaseGrammarAccess.XNullLiteralElements getXNullLiteralAccess() {
		return gaXbase.getXNullLiteralAccess();
	}
	
	public ParserRule getXNullLiteralRule() {
		return getXNullLiteralAccess().getRule();
	}
	
	//XNumberLiteral XExpression:
	//	{XNumberLiteral} value=Number;
	public XbaseGrammarAccess.XNumberLiteralElements getXNumberLiteralAccess() {
		return gaXbase.getXNumberLiteralAccess();
	}
	
	public ParserRule getXNumberLiteralRule() {
		return getXNumberLiteralAccess().getRule();
	}
	
	//XStringLiteral XExpression:
	//	{XStringLiteral} value=STRING;
	public XbaseGrammarAccess.XStringLiteralElements getXStringLiteralAccess() {
		return gaXbase.getXStringLiteralAccess();
	}
	
	public ParserRule getXStringLiteralRule() {
		return getXStringLiteralAccess().getRule();
	}
	
	//XTypeLiteral XExpression:
	//	{XTypeLiteral} 'typeof' '(' type=[types::JvmType|QualifiedName] arrayDimensions+=ArrayBrackets* ')';
	public XbaseGrammarAccess.XTypeLiteralElements getXTypeLiteralAccess() {
		return gaXbase.getXTypeLiteralAccess();
	}
	
	public ParserRule getXTypeLiteralRule() {
		return getXTypeLiteralAccess().getRule();
	}
	
	//XThrowExpression XExpression:
	//	{XThrowExpression} 'throw' expression=XExpression;
	public XbaseGrammarAccess.XThrowExpressionElements getXThrowExpressionAccess() {
		return gaXbase.getXThrowExpressionAccess();
	}
	
	public ParserRule getXThrowExpressionRule() {
		return getXThrowExpressionAccess().getRule();
	}
	
	//XReturnExpression XExpression:
	//	{XReturnExpression} 'return' -> expression=XExpression?;
	public XbaseGrammarAccess.XReturnExpressionElements getXReturnExpressionAccess() {
		return gaXbase.getXReturnExpressionAccess();
	}
	
	public ParserRule getXReturnExpressionRule() {
		return getXReturnExpressionAccess().getRule();
	}
	
	//XTryCatchFinallyExpression XExpression:
	//	{XTryCatchFinallyExpression}
	//	'try'
	//	expression=XExpression (catchClauses+=XCatchClause+ (=> 'finally' finallyExpression=XExpression)?
	//	| 'finally' finallyExpression=XExpression);
	public XbaseGrammarAccess.XTryCatchFinallyExpressionElements getXTryCatchFinallyExpressionAccess() {
		return gaXbase.getXTryCatchFinallyExpressionAccess();
	}
	
	public ParserRule getXTryCatchFinallyExpressionRule() {
		return getXTryCatchFinallyExpressionAccess().getRule();
	}
	
	//XSynchronizedExpression XExpression:
	//	=> ({XSynchronizedExpression}
	//	'synchronized' '(') param=XExpression ')' expression=XExpression;
	public XbaseGrammarAccess.XSynchronizedExpressionElements getXSynchronizedExpressionAccess() {
		return gaXbase.getXSynchronizedExpressionAccess();
	}
	
	public ParserRule getXSynchronizedExpressionRule() {
		return getXSynchronizedExpressionAccess().getRule();
	}
	
	//XCatchClause:
	//	=> 'catch' '(' declaredParam=FullJvmFormalParameter ')' expression=XExpression;
	public XbaseGrammarAccess.XCatchClauseElements getXCatchClauseAccess() {
		return gaXbase.getXCatchClauseAccess();
	}
	
	public ParserRule getXCatchClauseRule() {
		return getXCatchClauseAccess().getRule();
	}
	
	//QualifiedName:
	//	ValidID (=> '.' ValidID)*;
	public XbaseGrammarAccess.QualifiedNameElements getQualifiedNameAccess() {
		return gaXbase.getQualifiedNameAccess();
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//Number hidden():
	//	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;
	public XbaseGrammarAccess.NumberElements getNumberAccess() {
		return gaXbase.getNumberAccess();
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	///**
	// * Dummy rule, for "better" downwards compatibility, since GrammarAccess generates non-static inner classes, 
	// * which makes downstream grammars break on classloading, when a rule is removed.
	// */ StaticQualifier:
	//	(ValidID '::')+;
	public XbaseGrammarAccess.StaticQualifierElements getStaticQualifierAccess() {
		return gaXbase.getStaticQualifierAccess();
	}
	
	public ParserRule getStaticQualifierRule() {
		return getStaticQualifierAccess().getRule();
	}
	
	//terminal HEX:
	//	('0x' | '0X') ('0'..'9' | 'a'..'f' | 'A'..'F' | '_')+ ('#' (('b' | 'B') ('i' | 'I') | ('l' | 'L')))?;
	public TerminalRule getHEXRule() {
		return gaXbase.getHEXRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9' ('0'..'9' | '_')*;
	public TerminalRule getINTRule() {
		return gaXbase.getINTRule();
	}
	
	//terminal DECIMAL:
	//	INT (('e' | 'E') ('+' | '-')? INT)? (('b' | 'B') ('i' | 'I' | 'd' | 'D') | ('l' | 'L' | 'd' | 'D' | 'f' | 'F'))?;
	public TerminalRule getDECIMALRule() {
		return gaXbase.getDECIMALRule();
	}
	
	//JvmTypeReference:
	//	JvmParameterizedTypeReference => ({JvmGenericArrayTypeReference.componentType=current} ArrayBrackets)*
	//	| XFunctionTypeRef;
	public XtypeGrammarAccess.JvmTypeReferenceElements getJvmTypeReferenceAccess() {
		return gaXtype.getJvmTypeReferenceAccess();
	}
	
	public ParserRule getJvmTypeReferenceRule() {
		return getJvmTypeReferenceAccess().getRule();
	}
	
	//ArrayBrackets:
	//	'[' ']';
	public XtypeGrammarAccess.ArrayBracketsElements getArrayBracketsAccess() {
		return gaXtype.getArrayBracketsAccess();
	}
	
	public ParserRule getArrayBracketsRule() {
		return getArrayBracketsAccess().getRule();
	}
	
	//XFunctionTypeRef:
	//	('(' (paramTypes+=JvmTypeReference (',' paramTypes+=JvmTypeReference)*)? ')')? '=>' returnType=JvmTypeReference;
	public XtypeGrammarAccess.XFunctionTypeRefElements getXFunctionTypeRefAccess() {
		return gaXtype.getXFunctionTypeRefAccess();
	}
	
	public ParserRule getXFunctionTypeRefRule() {
		return getXFunctionTypeRefAccess().getRule();
	}
	
	//JvmParameterizedTypeReference:
	//	type=[JvmType|super::QualifiedName] (=> '<' arguments+=JvmArgumentTypeReference (','
	//	arguments+=JvmArgumentTypeReference)* '>' (=> ({JvmInnerTypeReference.outer=current} '.') type=[JvmType|ValidID] (=>
	//	'<' arguments+=JvmArgumentTypeReference (',' arguments+=JvmArgumentTypeReference)* '>')?)*)?;
	public XtypeGrammarAccess.JvmParameterizedTypeReferenceElements getJvmParameterizedTypeReferenceAccess() {
		return gaXtype.getJvmParameterizedTypeReferenceAccess();
	}
	
	public ParserRule getJvmParameterizedTypeReferenceRule() {
		return getJvmParameterizedTypeReferenceAccess().getRule();
	}
	
	//JvmArgumentTypeReference JvmTypeReference:
	//	JvmTypeReference | JvmWildcardTypeReference;
	public XtypeGrammarAccess.JvmArgumentTypeReferenceElements getJvmArgumentTypeReferenceAccess() {
		return gaXtype.getJvmArgumentTypeReferenceAccess();
	}
	
	public ParserRule getJvmArgumentTypeReferenceRule() {
		return getJvmArgumentTypeReferenceAccess().getRule();
	}
	
	//JvmWildcardTypeReference:
	//	{JvmWildcardTypeReference} '?' (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*
	//	| constraints+=JvmLowerBound constraints+=JvmLowerBoundAnded*)?;
	public XtypeGrammarAccess.JvmWildcardTypeReferenceElements getJvmWildcardTypeReferenceAccess() {
		return gaXtype.getJvmWildcardTypeReferenceAccess();
	}
	
	public ParserRule getJvmWildcardTypeReferenceRule() {
		return getJvmWildcardTypeReferenceAccess().getRule();
	}
	
	//JvmUpperBound:
	//	'extends' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundElements getJvmUpperBoundAccess() {
		return gaXtype.getJvmUpperBoundAccess();
	}
	
	public ParserRule getJvmUpperBoundRule() {
		return getJvmUpperBoundAccess().getRule();
	}
	
	//JvmUpperBoundAnded JvmUpperBound:
	//	'&' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundAndedElements getJvmUpperBoundAndedAccess() {
		return gaXtype.getJvmUpperBoundAndedAccess();
	}
	
	public ParserRule getJvmUpperBoundAndedRule() {
		return getJvmUpperBoundAndedAccess().getRule();
	}
	
	//JvmLowerBound:
	//	'super' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundElements getJvmLowerBoundAccess() {
		return gaXtype.getJvmLowerBoundAccess();
	}
	
	public ParserRule getJvmLowerBoundRule() {
		return getJvmLowerBoundAccess().getRule();
	}
	
	//JvmLowerBoundAnded JvmLowerBound:
	//	'&' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundAndedElements getJvmLowerBoundAndedAccess() {
		return gaXtype.getJvmLowerBoundAndedAccess();
	}
	
	public ParserRule getJvmLowerBoundAndedRule() {
		return getJvmLowerBoundAndedAccess().getRule();
	}
	
	//JvmTypeParameter:
	//	name=ValidID (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*)?;
	public XtypeGrammarAccess.JvmTypeParameterElements getJvmTypeParameterAccess() {
		return gaXtype.getJvmTypeParameterAccess();
	}
	
	public ParserRule getJvmTypeParameterRule() {
		return getJvmTypeParameterAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	super::QualifiedName '.' '*';
	public XtypeGrammarAccess.QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return gaXtype.getQualifiedNameWithWildcardAccess();
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//ValidID:
	//	ID;
	public XtypeGrammarAccess.ValidIDElements getValidIDAccess() {
		return gaXtype.getValidIDAccess();
	}
	
	public ParserRule getValidIDRule() {
		return getValidIDAccess().getRule();
	}
	
	//XImportSection:
	//	importDeclarations+=XImportDeclaration+;
	public XtypeGrammarAccess.XImportSectionElements getXImportSectionAccess() {
		return gaXtype.getXImportSectionAccess();
	}
	
	public ParserRule getXImportSectionRule() {
		return getXImportSectionAccess().getRule();
	}
	
	//XImportDeclaration:
	//	'import' (static?='static' extension?='extension'? importedType=[JvmDeclaredType|QualifiedNameInStaticImport]
	//	(wildcard?='*' | memberName=ValidID) | importedType=[JvmDeclaredType|super::QualifiedName] |
	//	importedNamespace=QualifiedNameWithWildcard) ';'?;
	public XtypeGrammarAccess.XImportDeclarationElements getXImportDeclarationAccess() {
		return gaXtype.getXImportDeclarationAccess();
	}
	
	public ParserRule getXImportDeclarationRule() {
		return getXImportDeclarationAccess().getRule();
	}
	
	//QualifiedNameInStaticImport:
	//	(ValidID '.')+;
	public XtypeGrammarAccess.QualifiedNameInStaticImportElements getQualifiedNameInStaticImportAccess() {
		return gaXtype.getQualifiedNameInStaticImportAccess();
	}
	
	public ParserRule getQualifiedNameInStaticImportRule() {
		return getQualifiedNameInStaticImportAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '$' | '_') ('a'..'z' | 'A'..'Z' | '$' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaXtype.getIDRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"'? |
	//	"'" ('\\' . | !('\\' | "'"))* "'"?;
	public TerminalRule getSTRINGRule() {
		return gaXtype.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaXtype.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaXtype.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaXtype.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaXtype.getANY_OTHERRule();
	}
}
