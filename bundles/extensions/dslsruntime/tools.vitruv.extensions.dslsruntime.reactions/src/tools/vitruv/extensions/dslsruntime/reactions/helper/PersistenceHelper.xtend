package tools.vitruv.extensions.dslsruntime.reactions.helper

import org.eclipse.emf.ecore.EObject
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.IProject
import org.eclipse.emf.common.util.URI
import edu.kit.ipd.sdq.commons.util.org.eclipse.emf.common.util.URIUtil
import tools.vitruv.framework.util.VitruviusConstants

final class PersistenceHelper {
	private new() {}
	
	static def EObject getModelRoot(EObject modelObject) {
		var result = modelObject;
		while (result.eContainer() !== null) {
			result = result.eContainer();
		}
		return result;
	}

	private static def URI getURIOfElementResourceFolder(EObject element) {
		return element.eResource().getURI().trimSegments(1);
	}

	private static def URI getURIOfElementProject(EObject element) {
		val elementUri = element.eResource().URI;
		if (elementUri.isPlatform) {
			val IFile sourceModelFile = URIUtil.getIFileForEMFUri(elementUri);
			val IProject projectSourceModel = sourceModelFile.getProject();
			var String srcFolderPath = projectSourceModel.getFullPath().toString();
			return URI.createPlatformResourceURI(srcFolderPath, true);
		} else if (elementUri.isFile) {
			return findTestProjectInFileURI(elementUri);
		} else {
			throw new UnsupportedOperationException("Other URI types than file and platform are currently not supported");
		}
	}
	
	/**  We use an identifier file generated by out TestUtils to detect the test project
	* although we are not in an Eclipse environment that knows about projects using
	* PlatformURIS
	*/
	private static def URI findTestProjectInFileURI(URI elementUri) {
		var potentialProjectUri = elementUri;
		// Remove last segment as long as the folder does not contain the 
		while (!URIUtil.existsResourceAtUri(potentialProjectUri.appendSegment(VitruviusConstants.testProjectMarkerFileName))
			&& potentialProjectUri.lastSegment !== null) {
			potentialProjectUri = potentialProjectUri.trimSegments(1);
		}
		if (potentialProjectUri.lastSegment === null) {
			throw new IllegalStateException("No project folder for " + elementUri+ " found");
		}
		return potentialProjectUri;
	}

	private static def URI appendPathToURI(URI baseURI, String relativePath) {
		val newModelFileSegments = relativePath.split("/");
		if (!newModelFileSegments.last.contains(".")) {
			throw new IllegalArgumentException("File extension must be specified");
		}
		return baseURI.appendSegments(newModelFileSegments);
	}

	static def URI getURIFromSourceResourceFolder(EObject source, String relativePath) {
		val baseURI = getURIOfElementResourceFolder(source);
		return baseURI.appendPathToURI(relativePath);
	}
	
	/**
	 * Returns the URI of the project folder, relative as specified in <code>relativePath</code>
	 * to the project root, determined from the element <code>source</code>.
	 * 
	 * @param source -
	 * 		An {@link EObject} that is persisted within a resource of the project
	 * @param relativePath -
	 * 		The relative path within the project to get the {@link URI} for, using "/" as separator char
	 * 
	 * @returns the {@link URI} of the folder within the project of the given element
	 */
	static def URI getURIFromSourceProjectFolder(EObject source, String relativePath) {
		val baseURI = getURIOfElementProject(source);
		return baseURI.appendPathToURI(relativePath);
	}

}
